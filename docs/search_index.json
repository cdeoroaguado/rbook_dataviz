[["etltidyverse.html", "Capítulo 2 ETL con Tidyverse 2.1 Data Frames 2.2 Importación de datos 2.3 Transformación de datos 2.4 Ordenación de datos", " Capítulo 2 ETL con Tidyverse El Tidyverse es un conjunto de paquetes integrados para el lenguaje de programación R, diseñados con el objetivo de facilitar el análisis de datos de manera estructurada, legible y eficiente. Su filosofía se basa en el concepto de “datos ordenados” (tidy data), donde cada variable es una columna, cada observación una fila, y cada tipo de unidad observacional forma una tabla. Estos paquetes comparten principios de diseño comunes y una gramática coherente, lo que permite a los usuarios aprender un conjunto de reglas aplicables en todo el ecosistema, aumentando así la productividad y la claridad del código. Figura 2.1: Paquetes de tidyverse 2.1 Data Frames Definición Un data frame es una estructura de datos clave en estadística y en R. La estructura básica de un data frame es que hay una observación por fila y cada columna representa una variable, medida, rasgo o característica de esa observación. R tiene una implementación interna de los data frames que probablemente es la que más se utiliza en la práctica. 2.2 Importación de datos Fuentes de datos en R Los conjuntos de datos de gran tamaño, generalmente almacenados como data frames en R, suelen provenir de archivos externos. Existen múltiples tipos de archivos que pueden importarse, entre ellos: Archivos de texto en formatos como csv, txt, html y json. Salidas de software estadístico como SAS y SPSS. Recursos en línea como páginas html y servicios web. Bases de datos relacionales y no relacionales. El ecosistema Tidyverse ofrece funciones que permiten importar y gestionar estas diversas fuentes de datos de manera sencilla y eficiente. 2.2.1 Importación de archivos csv con read.table() Definición La función read.table() es una función integrada en R que permite leer archivos de distintos formatos y convertirlos en un data frame. Es una de las funciones más utilizadas para importar archivos simples en R. La sintaxis de read.table() requiere indicar: - Un nombre de archivo (ruta de acceso). - Un valor lógico (TRUE/FALSE) para definir si la primera fila contiene los nombres de las columnas. Si se establece en TRUE, la primera fila se interpreta como encabezado. Si se establece en FALSE, las columnas se importan sin nombres definidos. El resultado de la función siempre es un data frame. Una alternativa práctica es la función file.choose(), que permite seleccionar el archivo de manera interactiva sin necesidad de escribir la ruta manualmente. Observación Pasos para importar un archivo csv con read.table(): Abrir RStudio y dirigirse a la consola. Establecer el directorio de trabajo con código en la consola o desde el menú: Sesión → Establecer directorio de trabajo → Elegir directorio. Ejecutar la función read.table() indicando el archivo csv a importar. Code setwd(&quot;~/Books_CienciaDatos/rbook_dataviz&quot;) Figura 2.2: setwd En la carpeta RDataSets se encuentra el archivo StudyArea.csv, que corresponde a un archivo separado por comas. Este archivo contiene información sobre incendios forestales ocurridos entre los años 1980 y 2016 en distintos estados de EE. UU., entre ellos: California, Oregón, Washington, Idaho, Montana, Wyoming, Colorado, Utah, Nevada, Arizona y Nuevo México. El archivo incluye más de 439000 registros distribuidos en 37 columnas, que describen las características de cada incendio durante ese periodo. Para cargar estos datos en un nuevo objeto data frame, puede utilizarse la función read.table() de la siguiente manera: Code df &lt;- read.table(&quot;data/StudyArea.csv&quot;, header = TRUE) Recibirá un mensaje de error cuando intente ejecutar esta línea de código. El mensaje de error mensaje de error debería aparecer como se ve a continuación Figura 2.3: error en rmd La razón por la que se generó un mensaje de error en este caso es que la función read.table() utiliza espacios como delimitador entre registros y nuestro archivo utiliza comas como delimitador Actualice su llamada a read.table() como se ve a continuación para incluir el argumento sep, que debería ser una coma Code df &lt;- read.table(&quot;data/StudyArea.csv&quot;, sep=&quot;,&quot;, header = TRUE) Cuando ejecute esta línea de código verá un nuevo error Figura 2.4: continuación del error en rmd La función read.table() no completa de manera automática las celdas vacías con un valor por defecto como NA. Por este motivo, si alguna fila del archivo no contiene el número esperado de columnas (en este caso, 14), se genera un mensaje de error durante la importación. Para solucionar este inconveniente, puede añadirse el parámetro fill = TRUE, lo que permite a R rellenar los espacios vacíos con NA y mantener la estructura correcta del data.frame. Code df &lt;- read.table(&quot;data/StudyArea.csv&quot;, header = TRUE, fill = TRUE, sep = &quot;,&quot;) nrow(df) ## [1] 153095 Al ejecutar esta instrucción, el contenido del archivo se importa a un objeto de tipo data frame. Sin embargo, al revisar la pestaña Global Environment en RStudio, se observa que solo se han cargado 153095 registros, a pesar de que el archivo original contiene más de 400000. La causa de esta diferencia suele estar en el manejo de las comillas (simples o dobles) presentes dentro del archivo csv, las cuales pueden interrumpir la lectura y provocar que algunos registros sean descartados. Para corregir este problema, se debe añadir el parámetro quote = \"\", que le indica a R que ignore las comillas y procese correctamente todas las filas del archivo. Code df = read.table(&quot;data/StudyArea.csv&quot;, header=TRUE, fill=TRUE, quote=&quot;\\&quot;&quot;, sep=&quot;,&quot;) nrow(df) ## [1] 439362 Al ejecutar esta línea de código, se deberían importar 440476 registros. Los datos se cargan en un objeto de tipo R data.frame, que es una estructura similar a una tabla. Por ahora, puede pensarse en ellos como tablas que contienen columnas y filas. Observación La función read.table() se utiliza normalmente para cargar archivos de texto delimitados por tabulaciones. Sin embargo, muchas personas intentan emplearla directamente con archivos en formato csv sin especificar los parámetros adecuados, lo que puede generar errores en la importación. Una alternativa más práctica es usar la función read.csv(), como veremos en el siguiente paso. 2.2.2 Importación de archivos txt delimitados por tabulación con read.table() La función read.table() se utiliza con frecuencia para leer el contenido de archivos delimitados por tabulaciones u otros separadores. En este ejemplo, se trabajará con el archivo all_genes_pombase.txt, ubicado en la carpeta RDataSets. Antes de importarlo en R, se recomienda abrir el archivo en Excel o en cualquier editor de texto para observar su estructura, campos y delimitadores. Una vez identificado el formato del archivo, en la consola de R puedes ejecutar el siguiente código para realizar la importación: Code # Lectura de archivo delimitado por tabulaciones genes &lt;- read.table(&quot;data/all_genes_pombase.txt&quot;, header = TRUE, sep = &quot;\\t&quot;, quote=&quot;\\&quot;&quot;) # numero de filas nrow(genes) ## [1] 7019 Code # Visualizar las primeras filas head(genes) ## ensembl_id name chromosome ## 1 SPAC1002.01 SPAC1002.01 I ## 2 SPAC1002.02 pom34 I ## 3 SPAC1002.03c gls2 I ## 4 SPAC1002.04c taf11 I ## 5 SPAC1002.05c jmj2 I ## 6 SPAC1002.06c bqt2 I ## description feature_type ## 1 conserved fungal protein protein_coding ## 2 nucleoporin Pom34 protein_coding ## 3 glucosidase II alpha subunit Gls2 protein_coding ## 4 transcription factor TFIID complex subunit Taf11 (predicted) protein_coding ## 5 histone demethylase Jmj2 protein_coding ## 6 bouquet formation protein Bqt2 protein_coding ## strand start end ## 1 1 1798347 1799015 ## 2 1 1799061 1800053 ## 3 -1 1799915 1803141 ## 4 -1 1803624 1804491 ## 5 -1 1804548 1806797 ## 6 -1 1807270 1807781 Esto permitirá cargar 7019 registros en un objeto data.frame. Es importante tener en cuenta que, aunque la función realiza la importación, varios de sus parámetros deben configurarse adecuadamente al momento de leer el dataset, lo que hace que el proceso no sea tan directo ni automático como podría suponerse inicialmente. 2.2.3 Importación de archivos csv con read.csv() Definición: read.csv() La función read.csv() es una función incorporada en R que permite importar archivos delimitados por comas (csv) de manera sencilla. Está diseñada específicamente para este tipo de archivos y establece de forma predeterminada el argumento header = TRUE (la primera fila se toma como nombres de columna) y sep = “,” (coma como delimitador de campos). Esto hace que read.csv() sea una de las formas más rápidas y eficientes de cargar datos en R cuando provienen de archivos csv. La función read.csv() es una función incorporada en R que resulta casi idéntica a read.table(). La principal diferencia es que en read.csv() los argumentos de cabecera y relleno se establecen en TRUE por defecto, lo que facilita la carga de archivos delimitados por comas (csv). En este punto, se observa que usar read.csv() implifica notablemente el proceso de importación. A diferencia de read.table(), la función read.csv() gestiona automáticamente la mayoría de las configuraciones necesarias al leer un archivo csv. Esto permite cargar correctamente incluso archivos con más de 400000 registros sin tener que especificar tantos parámetros manualmente. Code # Lectura de archivo CSV con read.csv() df &lt;- read.csv(&quot;data/StudyArea.csv&quot;) # numero de fila nrow(df) ## [1] 439362 2.2.4 Uso de readr de tidyverse Definición: readr readr es el paquete del ecosistema tidyverse para lectura y escritura rápida de datos tabulares. Produce objetos tibble, maneja de forma estable codificaciones (UTF-8), tipos de columna y valores perdidos, e incluye herramientas para diagnosticar problemas de importación. Su API es consistente, minimalista y pensada para flujos reproducibles. Ventajas claves Velocidad y consistencia en lectura/escritura de archivos delimitados. Tipos de columnas explícitos con col_types y funciones col_*. Diagnóstico con spec() y problems(). Salida en tibble (imprime y maneja mejor columnas anchas/fechas). Soporte de locales (locale()) para decimales, fechas, codificación, etc. Funciones principales de lectura Función Propósito Formato/Delimitador read_csv() csv con punto como decimal , read_csv2() csv europeo (coma decimal) ; read_tsv() Valores separados por tabulador \\t read_delim(delim=) Delimitador personalizado Cualquiera (p. ej. \\|, :) read_table() Columnas separadas por espacios Espacios en blanco read_fwf() Formato de ancho fijo Anchos/posiciones read_lines() Leer líneas como vector de caracteres Texto read_file() Leer archivo completo como cadena única Texto read_rds() Leer archivo R serializado .rds Funciones de escritura Función Propósito write_csv() Escribir csv (punto decimal) write_csv2() Escribir csv (coma decimal) write_tsv() Escribir delimitado por tabulador write_delim() Escribir con delimitador personalizado write_rds() Guardar objeto R en .rds Argumentos comunes (lectura) Argumento Qué controla Ejemplo col_types Tipos de columnas (explícitos) col_types = cols(id = col_integer()) na Cadenas que se tratarán como NA na = c(\"\", \"NA\", \"NULL\") locale Configuración regional (decimal, fecha, tz, encoding) locale(decimal_mark = \",\") skip / n_max Filas a omitir / máximo de filas a leer skip = 2, n_max = 1e5 comment Prefijo de comentario para ignorar líneas comment = \"#\" guess_max Filas usadas para “adivinar” tipos guess_max = 100000 show_col_types Muestra la conjetura de tipos al leer show_col_types = FALSE Tip: cuando los tipos son críticos, no confíes solo en la inferencia: pasa col_types explícito. Veamos el siguiente ejemplo. Carguemos los siguientes datos: Code library(readr) # CSV con punto decimal y encabezados dfReadr &lt;- read_csv(&quot;data/StudyArea.csv&quot;, col_types = cols(.default = &quot;c&quot;), # Columnas (.default) como &quot;character&quot; col_names = TRUE) # la 1ra fila como nombres de las columnas head(dfReadr) ## # A tibble: 6 × 14 ## FID ORGANIZATI UNIT SUBUNIT SUBUNIT2 FIRENAME CAUSE YEAR_ STARTDATED ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 0 FWS 81682 USCADBR San Diego Bay … PUMP HO… Human 2001 1/1/01 0:… ## 2 1 FWS 81682 USCADBR San Diego Bay … I5 Human 2002 5/3/02 0:… ## 3 2 FWS 81682 USCADBR San Diego Bay … SOUTHBAY Human 2002 6/1/02 0:… ## 4 3 FWS 81682 USCADBR San Diego Bay … MARINA Human 2001 7/12/01 0… ## 5 4 FWS 81682 USCADBR San Diego Bay … HILL Human 1994 9/13/94 0… ## 6 5 FWS 81682 USCADBR San Diego Bay … IRRIGAT… Human 1994 4/22/94 0… ## # ℹ 5 more variables: CONTRDATED &lt;chr&gt;, OUTDATED &lt;chr&gt;, STATE &lt;chr&gt;, ## # STATE_FIPS &lt;chr&gt;, TOTALACRES &lt;chr&gt; Code spec(dfReadr) # Esquema de tipos ## cols( ## .default = col_character(), ## FID = col_character(), ## ORGANIZATI = col_character(), ## UNIT = col_character(), ## SUBUNIT = col_character(), ## SUBUNIT2 = col_character(), ## FIRENAME = col_character(), ## CAUSE = col_character(), ## YEAR_ = col_character(), ## STARTDATED = col_character(), ## CONTRDATED = col_character(), ## OUTDATED = col_character(), ## STATE = col_character(), ## STATE_FIPS = col_character(), ## TOTALACRES = col_character() ## ) Al ejecutar nuevamente la función sin el argumento col_types, R* intentará detectar automáticamente el tipo de dato de cada columna. En este proceso se mostrará primero un listado con los nombres de las columnas y el tipo asignado a cada una, seguido de un mensaje de advertencia que indica la presencia de errores de análisis durante la importación, lo cual ejemplifica las inconsistencias que pueden surgir al dejar la inferencia de tipos en manos del sistema. Actualice el código como se muestra a continuación y ejecútelo nuevamente. En este caso, se especifica que la columna UNIT debe ser importada como un dato de tipo carácter (texto): Code dfReadr = read_csv(&quot;data/StudyArea.csv&quot;, col_types = list(FID = col_character()), col_names = TRUE) head(dfReadr) ## # A tibble: 6 × 14 ## FID ORGANIZATI UNIT SUBUNIT SUBUNIT2 FIRENAME CAUSE YEAR_ STARTDATED ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 0 FWS 81682 USCADBR San Diego Bay … PUMP HO… Human 2001 1/1/01 0:… ## 2 1 FWS 81682 USCADBR San Diego Bay … I5 Human 2002 5/3/02 0:… ## 3 2 FWS 81682 USCADBR San Diego Bay … SOUTHBAY Human 2002 6/1/02 0:… ## 4 3 FWS 81682 USCADBR San Diego Bay … MARINA Human 2001 7/12/01 0… ## 5 4 FWS 81682 USCADBR San Diego Bay … HILL Human 1994 9/13/94 0… ## 6 5 FWS 81682 USCADBR San Diego Bay … IRRIGAT… Human 1994 4/22/94 0… ## # ℹ 5 more variables: CONTRDATED &lt;chr&gt;, OUTDATED &lt;chr&gt;, STATE &lt;chr&gt;, ## # STATE_FIPS &lt;dbl&gt;, TOTALACRES &lt;dbl&gt; 2.3 Transformación de datos Antes de realizar un análisis de datos en R, con frecuencia es necesario manipular o transformar la información de distintas formas. Para ello, el paquete dplyr, que hace parte del ecosistema tidyverse, ofrece un conjunto de funciones que facilitan la transformación y manejo de datos de manera eficiente y estructurada. En esta sección abordaremos los siguientes aspectos fundamentales: Filtrar registros para obtener subconjuntos de datos Seleccionar y limitar columnas específicas Ordenar filas en forma ascendente o descendente Incorporar nuevas filas a un conjunto existente Resumir y agrupar información Utilizar canalización (pipes) para mejorar la legibilidad y eficiencia del código 2.3.1 El paquete dplyr Definición El paquete dplyr fue desarrollado por Hadley Wickham de RStudio y es una versión optimizada y destilada de su paquete plyr. Una importante contribución de dplyr es que proporciona una gramática (en particular, verbos) para la manipulación de datos y operación con data frames. Con esta gramática se puede comunicar de forma comprensible lo que se está haciendo a un data frame, lo cual es muy útil porque proporciona una abstracción para la manipulación de datos que antes no existía. Otra ventaja es que las funciones de dplyr son muy rápidas, ya que muchas operaciones clave están codificadas en C++. 2.3.2 Operador %&gt;% El operador pipeline %&gt;% resulta muy útil para encadenar múltiples funciones de dplyr en una secuencia de operaciones. Antes de usarlo, cuando se necesitaba aplicar varias funciones de manera consecutiva, la expresión debía escribirse como una secuencia de funciones anidadas, lo cual resulta poco legible. Por ejemplo: Code third(second(first(x))) Este estilo de anidamiento no refleja la manera natural de pensar en una secuencia de pasos. En cambio, el operador %&gt;% permite expresar la secuencia de izquierda a derecha, facilitando la lectura y comprensión del código. Code first(x) %&gt;% second %&gt;% third 2.3.3 Filtrar datos para crear un subconjunto Definición: filter() La función filter() del paquete dplyr se utiliza para extraer subconjuntos de filas de un dataframe en función de una o más condiciones lógicas. Es similar a la función subset() de R base, pero resulta más rápida y eficiente. El primer argumento que recibe filter() siempre es un objeto de tipo dataframe, mientras que los argumentos adicionales corresponden a las expresiones condicionales que definen el filtrado. Ejemplo de incendios forestales El repositorio RDataSets contiene el archivo StudyArea.csv, un archivo separado por comas con información de incendios forestales ocurridos entre los años 1980 y 2016 en los estados de California, Oregón, Washington, Idaho, Montana, Wyoming, Colorado, Utah, Nevada, Arizona y Nuevo México. Este archivo cuenta con aproximadamente 439.000 registros y 37 columnas que describen las características de cada incendio durante este periodo. En este dataframe de incendios forestales tiene una columna llamada TOTALACRES, la cual registra el número de acres quemados por evento. Code df &lt;- read.csv(&quot;data/StudyArea.csv&quot;) head(df,n=3) ## FID ORGANIZATI UNIT SUBUNIT SUBUNIT2 ## 1 0 FWS 81682 USCADBR San Diego Bay National Wildlife Refuge ## 2 1 FWS 81682 USCADBR San Diego Bay National Wildlife Refuge ## 3 2 FWS 81682 USCADBR San Diego Bay National Wildlife Refuge ## FIRENAME CAUSE YEAR_ STARTDATED CONTRDATED OUTDATED STATE STATE_FIPS ## 1 PUMP HOUSE Human 2001 1/1/01 0:00 1/1/01 0:00 California 6 ## 2 I5 Human 2002 5/3/02 0:00 5/3/02 0:00 California 6 ## 3 SOUTHBAY Human 2002 6/1/02 0:00 6/1/02 0:00 California 6 ## TOTALACRES ## 1 0.1 ## 2 3.0 ## 3 0.5 Solución Crear un subconjunto de registros que contenga sólo los incendios forestales de más de \\(25000\\) acres. Code library(tidyverse) df %&gt;% filter(TOTALACRES &gt;= 25000) Crear un subconjunto de registros que contenga sólo los incendios forestales de más de \\(1000\\) acres en el año \\(2016\\). Code df %&gt;% filter(TOTALACRES &gt;= 1000,YEAR_== 2016) Crear un subconjunto de registros que contenga sólo los incendios forestales de más de \\(1000\\) acres en el año \\(2016\\), pero usa el operador &amp;. Code df %&gt;% filter(TOTALACRES &gt;= 1000 &amp; YEAR_== 2016) Crear un subconjunto de registros que contenga sólo los años \\(2010\\), \\(2011\\) y \\(2012\\) Code df %&gt;% filter(YEAR_ %in% c(2010, 2011, 2012)) 2.3.4 Acotar la lista de columnas con select() Definición: select() La función select() del paquete dplyr se emplea para elegir columnas específicas de un dataframe. Es especialmente útil cuando se trabaja con conjuntos de datos extensos y solo se requiere un subconjunto de variables. Continuando con el ejemplo de las incendios forestales Selecciona las columnas FIRENAME, TOTALACRES, YEAR_ Code df %&gt;% select(FIRENAME, TOTALACRES, YEAR_) Selecciona las columnas FIRENAME, TOTALACRES, YEAR_, cambian el nombre de TOTALACRES por ACRES y YEAR_ por YR. Code df %&gt;% select(&quot;FIRE&quot; = &quot;FIRENAME&quot;, &quot;ACRES&quot; =&quot;TOTALACRES&quot;, &quot;YR&quot; = &quot;YEAR_&quot;) Selecciona las columnas que contengan la palabra DATE Code df %&gt;% select(contains(&quot;DATE&quot;)) Selecciona las columnas que contengan la palabra DATE y también inicien con TOTAL Code df %&gt;% select(contains(&quot;DATE&quot;),starts_with(&quot;TOTAL&quot;)) Funciones de ayuda para select() La función select() puede complementarse con una serie de funciones auxiliares que permiten filtrar las columnas de manera más flexible y eficiente. Estas funciones son especialmente útiles cuando se trabaja con conjuntos de datos amplios o cuando los nombres de las variables siguen un patrón específico. starts_with(“texto”): selecciona las columnas cuyos nombres comienzan con el texto indicado. ends_with(“texto”): selecciona las columnas cuyos nombres terminan con el texto indicado. contains(“texto”): selecciona las columnas cuyos nombres contienen el texto indicado. matches(“regex”): selecciona las columnas cuyos nombres cumplen con una expresión regular. num_range(“x”, 1:5): selecciona un rango de columnas numeradas (ejemplo: x1, x2, …, x5). 2.3.5 Organizar las filas Definición: arrange() La función arrange() del paquete dplyr se utiliza para ordenar las filas de un dataframe en función de una o varias columnas. De manera predeterminada, organiza en orden ascendente, aunque puede invertirse a orden descendente con la función desc(). Continuando con el ejemplo de los incendios forestales Filtrar el conjunto de datos para que contenga solo los incendios de más de 1.000 acres quemados del año 2016. Despues selecciona las columnas FIRENAME, TOTALACRES, YEAR_ y renombralas NAME, ACRES, YR, respectivamente. Finalmente, ordena ACRES de forma ascendente y muestrame las 5 ultimas. Code df %&gt;% filter(TOTALACRES &gt;= 1000, YEAR_ == 2016) %&gt;% select(&quot;NAME&quot; = &quot;FIRENAME&quot;, &quot;ACRES&quot; = &quot;TOTALACRES&quot;, &quot;YR&quot; = &quot;YEAR_&quot;) %&gt;% arrange(ACRES) %&gt;% tail(n=5) ## NAME ACRES YR ## 148 Cedar 45977 2016 ## 149 Erskine 48007 2016 ## 150 Range 12 171915 2016 ## 151 Junkins 181320 2016 ## 152 PIONEER 188404 2016 Filtrar el conjunto de datos para que contenga solo los incendios de más de 2.000 acres quemados del año 2016. Despues selecciona las columnas FIRENAME, TOTALACRES, YEAR_ y renombralas NAME, ACRES, YR, respectivamente. Finalmente, ordena ACRES de forma descendente y muestrame las 5 primeras. Code df %&gt;% filter(TOTALACRES &gt;= 2000, YEAR_ == 2016) %&gt;% select(&quot;NAME&quot; = &quot;FIRENAME&quot;, &quot;ACRES&quot; = &quot;TOTALACRES&quot;, &quot;YR&quot; = &quot;YEAR_&quot;) %&gt;% arrange(desc(ACRES)) %&gt;% head(n=5) ## NAME ACRES YR ## 1 PIONEER 188404 2016 ## 2 Junkins 181320 2016 ## 3 Range 12 171915 2016 ## 4 Erskine 48007 2016 ## 5 Cedar 45977 2016 2.3.6 Añadir columnas con mutate Definición: mutate() La función mutate() del paquete dplyr se utiliza para crear nuevas variables o transformar las existentes dentro de un dataframe. Es especialmente útil cuando se desea generar columnas derivadas a partir de operaciones aritméticas, funciones estadísticas o transformaciones sobre variables ya presentes en los datos. Gracias a su sintaxis sencilla y legible, mutate() ofrece una forma clara y estructurada de enriquecer un conjunto de datos sin necesidad de sobrescribir la información original. Continuando con el ejemplo de los incendios forestales Seleccione únicamente las columnas ORGANIZATI, STATE, YEAR_, TOTALACRES, CAUSE y STARTDATED, filtre los registros para que solo se incluyan los incendios con más de 1.000 acres quemados y cuya causa sea Humana o Natural, cree una nueva columna llamada DOY que indique el día del año en que inició cada incendio a partir de la columna STARTDATED, y finalmente muestre las primeras filas del resultado. Carguemos nuevamente los datos Code df %&gt;% select(ORGANIZATI, STATE, YEAR_, TOTALACRES, CAUSE, STARTDATED) %&gt;% filter(TOTALACRES &gt;= 1000 &amp; CAUSE %in% c(&quot;Human&quot;, &quot;Natural&quot;)) %&gt;% mutate(DOY = yday(as.Date(STARTDATED, format=&quot;%m/%d/%y%H:%M&quot;))) -&gt; df_sol # Vista rápida knitr::kable(head(df_sol)) ORGANIZATI STATE YEAR_ TOTALACRES CAUSE STARTDATED DOY FWS Arizona 1988 1500 Human 3/26/88 0:00 86 FWS Arizona 1986 10390 Human 5/15/86 0:00 135 FWS Montana 1986 1400 Human 6/27/86 0:00 178 FWS Arizona 2002 1035 Human 2/28/02 0:00 59 FWS Arizona 2000 5700 Human 4/9/00 0:00 100 FWS Arizona 2000 2750 Human 5/14/00 0:00 135 Observación sobre lubridate El paquete lubridate del ecosistema tidyverse está diseñado para simplificar la manipulación de fechas y tiempos en R. Proporciona funciones intuitivas como ymd(), mdy() o dmy() para convertir cadenas en objetos de tipo fecha, así como ymd_hms() o mdy_hm() para manejar fechas con hora, minutos y segundos. Además, incluye utilidades como yday() (día del año), wday() (día de la semana), month() o year(), que permiten extraer y operar sobre componentes específicos de una fecha de manera clara y eficiente. En comparación con las funciones base de R, lubridate ofrece una sintaxis más legible y reduce errores asociados al manejo de distintos formatos de fecha y hora. Función Descripción Ejemplo ymd() Convierte cadenas con formato Año-Mes-Día a fecha (YYYY-MM-DD). ymd(\"2023-08-21\") → 2023-08-21 mdy() Convierte cadenas con formato Mes-Día-Año a fecha (MM-DD-YYYY). mdy(\"08-21-2023\") → 2023-08-21 dmy() Convierte cadenas con formato Día-Mes-Año a fecha (DD-MM-YYYY). dmy(\"21-08-2023\") → 2023-08-21 ymd_hms() Convierte a fecha con hora, minutos y segundos. ymd_hms(\"2023-08-21 14:30:15\") mdy_hm() Convierte a fecha con hora y minutos. mdy_hm(\"08-21-2023 14:30\") year() Extrae el año de una fecha. year(ymd(\"2023-08-21\")) → 2023 month() Extrae el mes de una fecha (numérico o etiqueta si label=TRUE). month(ymd(\"2023-08-21\"), label=TRUE) → Aug day() Extrae el día del mes. day(ymd(\"2023-08-21\")) → 21 yday() Devuelve el día del año (1–365/366). yday(ymd(\"2023-08-21\")) → 233 wday() Devuelve el día de la semana (numérico o etiqueta si label=TRUE). wday(ymd(\"2023-08-21\"), label=TRUE) → Mon hour(), minute(), second() Extraen hora, minutos o segundos de un objeto fecha-hora. hour(ymd_hms(\"2023-08-21 14:30:15\")) → 14 2.3.7 Agrupación y resumen de los datos Definición: group_by() La función group_by() del paquete dplyr se utiliza para agrupar un dataframe en función de una o varias variables. Este agrupamiento no modifica los datos en sí, sino que establece una estructura que permite aplicar funciones de resumen o transformación sobre cada grupo de manera independiente. Generalmente, group_by() se usa en combinación con summarise(), mutate() u otras funciones de dplyr. Continuando con el ejemplo de incendios forestales Seleccione únicamente las columnas ORGANIZATI, STATE, YEAR_, TOTALACRES y CAUSE , filtre los registros para que solo se incluyan los incendios con más de 1.000 acres quemados, cree una nueva columna llamada DECADE que define la década en la que se produjo cada incendio, agrupa porDECADE y finalmente un resumen numérico completo del tamaño de los incendios forestales por década. Code df %&gt;% select(ORGANIZATI, STATE, YEAR_, TOTALACRES, CAUSE) %&gt;% filter(TOTALACRES &gt;= 1000) %&gt;% mutate(DECADE = ifelse(YEAR_ %in% 1980:1989, &quot;1980-1989&quot;, ifelse(YEAR_ %in% 1990:1999, &quot;1990-1999&quot;, ifelse(YEAR_ %in% 2000:2009, &quot;2000-2009&quot;, ifelse(YEAR_ %in% 2010:2016, &quot;2010-2016&quot;, &quot;-99&quot;))))) %&gt;% group_by(DECADE) %&gt;% summarise(media_acres = mean(TOTALACRES), ds_acres = sd(TOTALACRES), mediana_acres = median(TOTALACRES), RIC_acres = IQR(TOTALACRES), min_acres = min(TOTALACRES), max_acres = max(TOTALACRES), q1_acres = quantile(TOTALACRES)[2], q3_acres = quantile(TOTALACRES)[4]) -&gt; df_sol_2 # Vista rápida knitr::kable(head(df_sol_2)) DECADE media_acres ds_acres mediana_acres RIC_acres min_acres max_acres q1_acres q3_acres 1980-1989 8128.645 23681.53 2887.5 5074.50 1000 427680.0 1543.25 6617.75 1990-1999 8333.036 18212.44 2925.0 5641.80 1000 231389.0 1545.00 7186.80 2000-2009 12329.181 30156.35 3653.5 7859.75 1000 590620.0 1803.00 9662.75 2010-2016 14443.197 39272.14 3926.0 8552.00 1000 558198.3 1782.00 10334.00 Ejercicio 1 para entregar A partir del dataset df, el cual trata de los incendios forestales, realice las siguientes tareas: Filtrar los registros para incluir únicamente los incendios ocurridos en el estado de Idaho. Seleccionar únicamente las columnas YEAR_, CAUSE y TOTALACRES. Renombrar estas columnas con nombres más claros y descriptivos. Agrupar la información por CAUSE y YEAR_. Resumir el total de acres quemados para cada combinación de causa y año. Elaborar una visualización que muestre los resultados de manera clara. Ejercicio 2 para entregar Trabajaremos con el conjunto de datos de 120 años de historia olímpica adquirido por Randi Griffin en Randi-Griffin y puesto a disposición en athlete_events. Su tarea consiste en identificar los cinco deportes más importantes según el mayor número de medallas otorgadas en el año 2016, y luego realizar el siguiente análisis: Genere una tabla que indique el número de medallas concedidas en cada uno de los cinco principales deportes en 2016. Elabore una tabla que muestre la distribución de la edad de los ganadores de medallas en los cinco principales deportes en 2016. Identifique qué equipos nacionales ganaron el mayor número de medallas en los cinco principales deportes en 2016. Presente un resumen de la tendencia del peso de los atletas masculinos y femeninos ganadores en los cinco principales deportes en 2016. 2.4 Ordenación de datos La ordenación de datos es una forma coherente de organizar los datos en R y puede facilitarse a través del paquete tidyr que se encuentra en el ecosistema tidyverse. Hay tres reglas que podemos seguir para hacer un conjunto de datos ordenado: Reglas de datos ordenados Cada variable debe tener su propia columna. Cada observación debe tener su propia fila. Cada valor debe tener su propia celda. Figura 2.5: Partes de los datos En primer lugar, tener una estructura de datos consistente es muy importante. Los paquetes que forman parte de tidyverse (incluyendo dplyr y ggplot2) están diseñados para trabajar con datos ordenados. Observación Asegurar que tus datos sean uniformes facilita el procesamiento eficiente de tus datos. Además, colocar las variables en columnas permite facilitar la vectorización en R. Muchos de los conjuntos de datos que encuentre no estarán ordenados y requerirán algo de trabajo por su parte. Puede haber muchas razones por las que un conjunto de datos no esté ordenado. A menudo, las personas que crearon el conjunto de datos no están familiarizadas con los principios de los datos ordenados. Otra razón común por la que los conjuntos de datos no están ordenados es que los datos se organizan a menudo para facilitar algo más que el análisis. Nota importante Para que la introducción de datos sea lo más fácil posible, en ocasiones se suelen organizar los datos de forma poco ordenada. Así, muchos conjuntos de datos requieren algún tipo de ordenación antes de poder empezar el análisis. El primer paso es averiguar cuáles son las variables y observaciones del conjunto de datos. Esto le facilitará la comprensión de lo que deben ser las columnas y las filas. Además, también tendrá que resolver uno o dos problemas comunes: deberá averiguar si una variable está repartida en varias columnas, y si una observación está dispersa en varias filas. Estos conceptos se conocen como reunión y dispersión. En esta sección veremos: Recopilación Distribución Separación Unión 2.4.1 Recopilación Un problema común en muchos conjuntos de datos es que los nombres de las columnas no son variables sino valores de una variable. En la figura siguiente, las columnas 1999 y 2000 son en realidad valores de la variable YEAR. Cada fila de la tabla existente representa en realidad dos observaciones. El paquete tidyr puede utilizarse para reunir estas columnas existentes en una nueva variable. En este caso, tenemos que crear una nueva columna llamada YEAR y luego reunir en esta los valores existentes en las columnas 1999 y 2000. Figura 2.6: Partes de los datos Definición de gather() La función gather() del paquete tidyr se utiliza para transformar datos de un formato ancho (wide) a un formato largo (long). Su objetivo principal es reunir varias columnas en una sola, creando una nueva variable que identifica los nombres de las columnas originales y otra que contiene los valores asociados. En otras palabras, gather() permite convertir columnas que representan valores en filas ordenadas, lo que facilita el análisis de datos bajo los principios de datos ordenados. Ejemplo práctico En este ejercicio aprenderás a utilizar la función gather() para realizar la tarea de ordenación de datos. Descargue el archivo CountryPopulation.csv localizado en RDataSets. Solución A continuación, tendrás que nombrar la variable de la nueva columna. Esto también se llama la clave key, y en este caso será la variable del año (year). Por último, tendrás que proporcionar el valor value, que es el nombre de la variable cuyos valores se reparten por las celdas. Figura 2.7: Ilustración de la función gather Carguemos los datos Code library(tidyverse) df = read_csv(&quot;data/CountryPopulation.csv&quot;) head(df,n=5) ## # A tibble: 5 × 10 ## `Country Name` `Country Code` `2010` `2011` `2012` `2013` `2014` `2015` `2016` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Aruba ABW 1.02e5 1.02e5 1.03e5 1.03e5 1.04e5 1.04e5 1.05e5 ## 2 Afghanistan AFG 2.88e7 2.97e7 3.07e7 3.17e7 3.28e7 3.37e7 3.47e7 ## 3 Angola AGO 2.34e7 2.42e7 2.51e7 2.60e7 2.69e7 2.79e7 2.88e7 ## 4 Albania ALB 2.91e6 2.91e6 2.90e6 2.90e6 2.89e6 2.88e6 2.88e6 ## 5 Andorra AND 8.44e4 8.38e4 8.24e4 8.08e4 7.92e4 7.80e4 7.73e4 ## # ℹ 1 more variable: `2017` &lt;dbl&gt; Utilice la función gather como se ve a continuación Code df2 = gather(df, &quot;2010&quot;, &quot;2011&quot;, &quot;2012&quot;, &quot;2013&quot;, &quot;2014&quot;, &quot;2015&quot;, &quot;2016&quot;, &quot;2017&quot;, key = &quot;YEAR&quot;, value = &quot;POPULATION&quot;) knitr::kable(head(df2, 5)) Country Name Country Code YEAR POPULATION Aruba ABW 2010 101669 Afghanistan AFG 2010 28803167 Angola AGO 2010 23369131 Albania ALB 2010 2913021 Andorra AND 2010 84449 Otra opción también sería la siguiente, cuando contamos con un gran número de columnas de este tipo, debemos usar la expresiones regulares. Code years &lt;- colnames(df)[grep(&quot;^\\\\d{4}$&quot;, colnames(df))] df2 &lt;- df %&gt;% gather(key = &quot;YEAR&quot;, value = &quot;POPULATION&quot;, all_of(years)) knitr::kable(head(df2, 5)) Country Name Country Code YEAR POPULATION Aruba ABW 2010 101669 Afghanistan AFG 2010 28803167 Angola AGO 2010 23369131 Albania ALB 2010 2913021 Andorra AND 2010 84449 Donde, en expresiones regulares, \"^\\\\d{4}$\" tiene el siguiente significado: ^ : Representa el inicio de una cadena. \\\\d : Representa un dígito. {4} : Indica que el elemento anterior (\\\\d, en este caso) debe aparecer exactamente 4 veces. $ : Representa el final de una cadena. En resumen, \"^\\\\d{4}$\" coincide con cualquier cadena que contenga exactamente 4 dígitos y no contenga ningún otro carácter adicional antes o después de los dígitos. 2.4.2 Distribución Concepto La distribución es el proceso opuesto a la reunión y se aplica cuando una sola observación está fragmentada en varias filas. Su objetivo es reorganizar los datos para que cada observación quede contenida en una única fila. En el diagrama siguiente, la tabla debería definir una observación de un país por año. Sin embargo, se observa que está repartida en dos filas: una para cases y otra para population. Figura 2.8: Distribución Para solucionar este problema, podemos utilizar la función spread() del paquete tidyr. Definición: Sintaxis de spread() La función spread() del paquete tidyr se utiliza para transformar un conjunto de datos de formato largo (long) a formato ancho (wide). Su propósito es distribuir los valores de una variable en varias columnas. Toma dos parámetros principales: key: columna que contiene los nombres de las variables que se convertirán en nuevas columnas. value: columna que contiene los valores que se ubicarán en las nuevas celdas. Instale el paquete devtools y los conjuntos de datos DSR utilizando el código que ve a continuación escribiendo en el panel de la consola. Alternativamente, puede utilizar el panel de paquetes para instalar los librerías Code # Instalar # install.packages(&quot;devtools&quot;) # devtools::install_github(&quot;garrettgman/DSR&quot;) library(devtools) Tomemos los datos de table2: Code knitr::kable(head(table2)) country year type count Afghanistan 1999 cases 745 Afghanistan 1999 population 19987071 Afghanistan 2000 cases 2666 Afghanistan 2000 population 20595360 Brazil 1999 cases 37737 Brazil 1999 population 172006362 Utilice la función spread() para corregir este problema. Code table2b = spread(table2, key = type, value = count) knitr::kable(head(table2b)) country year cases population Afghanistan 1999 745 19987071 Afghanistan 2000 2666 20595360 Brazil 1999 37737 172006362 Brazil 2000 80488 174504898 China 1999 212258 1272915272 China 2000 213766 1280428583 2.4.3 Separación Otro caso común es el de dos variables que se colocan en la misma columna. Por ejemplo, la hoja de cálculo siguiente tiene una columna State-County Name que en realidad contiene dos variables separadas por una barra. Figura 2.9: DataSet La función separate() puede utilizarse para dividir una columna en varias columnas dividiendo por un separador. Por defecto, la función separate() buscará automáticamente cualquier carácter no alfanumérico o se puede definir un carácter específico (ver separate()). En la carpeta de RDataSets hay un archivo llamado usco2005.csv. Abra este archivo, por ejemplo con Microsoft Excel, o algún otro tipo de software de hoja de cálculo. El archivo debería tener un aspecto similar al de la captura de pantalla de abajo. Figura 2.10: DataSet de usco2005 Cargue el archivo usco2005.csv en RStudio escribiendo el código que ve a continuación en el panel de la consola Code df = read_csv(&quot;data/usco2005.csv&quot;) knitr::kable(head(df, 5)) STATE STATEFIPS COUNTYFIPS FIPS State-County Name TP-TotPop AL 1 1 1001 Alabama-Autauga County 48.612 AL 1 3 1003 Alabama-Baldwin County 162.586 AL 1 5 1005 Alabama-Barbour County 28.414 AL 1 7 1007 Alabama-Bibb County 21.516 AL 1 9 1009 Alabama-Blount County 55.725 Utilice la función separate() para separar el contenido de la columna State-County Name en las columnas StateAbbrev y CountyName Code df2 = separate(df, &quot;State-County Name&quot;,into = c(&quot;StateAbbrev&quot;, &quot;CountyName&quot;)) knitr::kable(head(df2, 5)) STATE STATEFIPS COUNTYFIPS FIPS StateAbbrev CountyName TP-TotPop AL 1 1 1001 Alabama Autauga 48.612 AL 1 3 1003 Alabama Baldwin 162.586 AL 1 5 1005 Alabama Barbour 28.414 AL 1 7 1007 Alabama Bibb 21.516 AL 1 9 1009 Alabama Blount 55.725 2.4.4 Unión Definición unite() de tidyr combina varias columnas en una sola, aplicando un separador entre los valores. Es, conceptualmente, la operación inversa de separate(). Parámetros clave data: marco de datos. col: nombre de la nueva columna combinada. …: columnas a unir (en el orden deseado). sep: separador entre valores (por defecto “_“). remove: si TRUE, elimina las columnas originales. na.rm: si TRUE, omite NA al unir; si FALSE, el resultado será NA si alguna parte es NA. Sintaxis: unite(data, col, …, sep = “_“, remove = TRUE, na.rm = FALSE) Code df3 = unite(df2, State_County_Name, StateAbbrev, CountyName) knitr::kable(head(df3, 5)) STATE STATEFIPS COUNTYFIPS FIPS State_County_Name TP-TotPop AL 1 1 1001 Alabama_Autauga 48.612 AL 1 3 1003 Alabama_Baldwin 162.586 AL 1 5 1005 Alabama_Barbour 28.414 AL 1 7 1007 Alabama_Bibb 21.516 AL 1 9 1009 Alabama_Blount 55.725 Ejercicio para entregar Considere el conjunto de datos us_state_population.tsv ubicado en la carpeta de datos de Python de github. Repita el procedimiento planteado en cada ítem de esta sección para obtener el nuevo dataframe con las nuevas columnas Year y Population. Realice unión y separación utilizando las columnas State y Code. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
