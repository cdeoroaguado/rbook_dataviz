[["vizshiny.html", "Capítulo 7 Visualización con shiny 7.1 El contexto: enfermedades cardiovasculares 7.2 Preparación del entorno 7.3 Ejercicios practicos", " Capítulo 7 Visualización con shiny Shiny es un marco para crear aplicaciones web reactivas con R. Combinado con plotly, permite construir gráficos interactivos que responden a entradas del usuario (filtros, clics, selección, zoom) sin salir del ecosistema de R. Por qué Shiny + plotly - Mantienes la gramática de R y obtienes una UI web sin escribir JavaScript. - plotly ya es interactivo; con Shiny reactivas los datos, controlas el estado y vinculas vistas. - Útil cuando necesitas: filtros en vivo, selección/brush, descargas, reportes o lógica del lado del servidor. Cuándo preferir solo plotly - Explorar/compartir un gráfico único sin lógica adicional (HTML autocontenido). - Documentos estáticos (Rmd) donde basta con hover/zoom y no hace falta estado compartido. Patrones clave Entradas → datos reactivos → renderPlotly() Vinculación entre gráficos con event_data() (clic/selección/hover/zoom). Crosstalk (highlight_key) para enlazar sin servidor (opcional). 7.1 El contexto: enfermedades cardiovasculares Construyamos un tablero con Shiny para la predicción de enfermedades cardiovasculares Antes de sumergirnos en el código, es crucial entender el “qué” y el “porqué” de nuestro proyecto. Vamos a explorar el problema que intentamos resolver y el conjunto de datos que será nuestra principal herramienta. Las enfermedades cardiovasculares (ECV) son la causa número 1 de muerte en el mundo. Se estima que cada año se cobran \\(17.9\\) millones de vidas, lo que representa el \\(31\\%\\) de todas las muertes a nivel global. El fallo cardíaco es un evento común causado por las ECV, y la detección temprana es clave para salvar vidas. Aquí es donde entra en juego el Machine Learning. Al analizar distintos factores de riesgo, podemos construir un modelo que ayude a los profesionales de la salud a predecir la probabilidad de que un paciente sufra una enfermedad cardíaca, permitiendo una intervención temprana y un mejor manejo de la condición. 7.1.1 Atributos del conjunto de datos Nuestro conjunto de datos contiene 918 observaciones (pacientes) y 11 características (atributos) que usaremos para entrenar nuestro modelo. La duodécima variable, HeartDisease, es nuestro objetivo a predecir. Nombre del Atributo Descripción Valores Posibles Age Edad del paciente Valor numérico Sex Sexo del paciente M (Masculino), F (Femenino) ChestPainType Tipo de dolor de pecho TA (Angina Típica), ATA (Angina Atípica), NAP (Dolor No Anginoso), ASY (Asintomático) RestingBP Presión arterial en reposo Valor numérico en mm Hg Cholesterol Colesterol sérico Valor numérico en mm/dl FastingBS Azúcar en sangre en ayunas 1 (&gt; 120 mg/dl), 0 (&lt;= 120 mg/dl) RestingECG Resultados del electrocardiograma en reposo Normal, ST (anormalidad de la onda ST-T), LVH (hipertrofia ventricular izquierda) MaxHR Frecuencia cardíaca máxima alcanzada Valor numérico (60-202) ExerciseAngina Angina inducida por el ejercicio Y (Sí), N (No) Oldpeak Depresión del ST inducida por el ejercicio en relación con el reposo Valor numérico ST_Slope Pendiente del segmento ST en el pico del ejercicio Up (ascendente), Flat (plano), Down (descendente) HeartDisease Clase de salida (objetivo) 1 (padece enfermedad cardíaca), 0 (Normal) 7.1.2 Origen y descarga Este es el conjunto de datos sobre enfermedades cardíacas más grande disponible para investigación hasta la fecha. Fue creado combinando cinco datasets diferentes del UCI Machine Learning Repository. Puedes descargar el dataset directamente desde Kaggle en el siguiente enlace: Descargar Dataset 7.1.3 Estructura de la App La app se dividirá en 3 pestañas: 7.2 Preparación del entorno 7.2.1 Estructura del código La estructura de carpetas de la aplicación será la siguiente: ├── App  ├── global.R ├── server.R ├── ui.R ├── heart.csv └── www/ └── heart-pulse.svg Nuestra aplicación se compondrá de 3 archivos de R principales que trabajan juntos: global.R: Se ejecuta primero. Contiene la carga de librerías, la carga de datos y el preprocesamiento. Todo lo que se defina aquí (variables, funciones, etc.) estará disponible para los archivos ui.R y server.R. ui.R: Define la interfaz de usuario. Contiene el objeto ui. server.R: Define la lógica del servidor. Contiene la función server. 7.2.2 Tarea 1: Crear proyecto de la app Crea la carpeta principal: En tu computadora, crea una nueva carpeta para el proyecto. Llámala TallerShiny_Corazon. Crea un nuevo proyecto de app en Shiny dando click en el icono que se encuentra en la esquina superior derecha. En el tipo de aplicación seleciona la opción de archivos multiples y crea la app en la carpeta que creaste. Por defecto solo se crean los archivos server.R y ui.R, por lo que se debe crear el archivo global.R manualmente en la carpeta de la app. Añade los demás Recursos: Crea una subcarpeta llamada exactamente www. Copia el archivo heart.csv y pégalo dentro de la carpeta principal TallerShiny_Corazon. Copia tu archivo de logo (p. ej., mi_logo.png) y pégalo dentro de la subcarpeta www. Puedes buscar logos en la siguiente pagina: Link 7.2.3 Tarea 2: Instalación de paquetes Ejecuta el siguiente comando en la consola para instalar todos los paquetes que usaremos: Code install.packages(c( &quot;shiny&quot;, # El motor principal de Shiny &quot;shinydashboard&quot;, # Para crear dashboards atractivos &quot;tidyverse&quot;, # Para manipulación de datos (dplyr) y gráficos (ggplot2) &quot;DT&quot;, # Para crear tablas de datos interactivas &quot;plotly&quot;, # Para hacer nuestros gráficos interactivos &quot;caret&quot;, # Para entrenar modelos de Machine Learning &quot;randomForest&quot;, # El algoritmo Random Forest &quot;pROC&quot; # Para calcular y dibujar la curva ROC )) 7.2.3.1 Creando la interfaz principal En este módulo, construiremos la estructura visual completa de nuestro dashboard: una cabecera profesional con nuestro logo, una barra lateral de navegación y un cuerpo principal donde vivirá nuestro contenido. En esta app, vamos a utilizar la libreria shinydashboard. Esta libreria facilita la creación de aplicacions al estilo de dashboards en Shiny. Referencia shinydashboard. Toda aplicación shinydashboard se envuelve en una función dashboardPage(). Esta función organiza los tres componentes principales: dashboardHeader(): La barra superior. dashboardSidebar(): El menú lateral. dashboardBody(): El área de contenido principal. 7.2.4 Tarea 3: Establecer la caja de herramientas Abre tu archivo global.R y añade el código para cargar todas las librerías y nuestro conjunto de datos. Este archivo se ejecutará una sola vez al iniciar la app. Code # --- Archivo: global.R --- # Cargar las librerías necesarias library(shiny) library(tidyverse) library(DT) # Para tablas interactivas library(caret) # Para el entrenamiento del modelo library(plotly) # Para gráficos interactivos library(pROC) # Para la curva ROC library(randomForest) # Requerido por caret para el método &#39;rf&#39; # Cargar y preparar los datos df &lt;- read.csv(&quot;heart.csv&quot;) # Renombrar la variable de salida para mayor claridad df &lt;- df %&gt;% rename(EnfermedadCorazon = HeartDisease) # Convertir variables a tipo &#39;factor&#39; para un mejor manejo df &lt;- df &lt;- df %&gt;% mutate( Sex = as.factor(Sex), ChestPainType = as.factor(ChestPainType), FastingBS = as.factor(FastingBS), RestingECG = as.factor(RestingECG), ExerciseAngina = as.factor(ExerciseAngina), ST_Slope = as.factor(ST_Slope), EnfermedadCorazon = as.factor(EnfermedadCorazon) ) # Cambiar los niveles de la variable objetivo por etiquetas más claras levels(df$EnfermedadCorazon) &lt;- c(&quot;No&quot;, &quot;Sí&quot;) # Mensaje de confirmación en la consola cat(&quot;Datos cargados y preprocesados en global.R\\n&quot;) 7.2.5 Tarea 4: Layout de la interfaz de usuario En esta tarea vamos a darle vida a la interfaz de usuario. En nuestro archivo ui.R, borramos el contenido para generar el layout base con dashboardPage(): Code # --- Archivo: ui.R --- library(shinydashboard) # Define la UI (Interfaz de Usuario) ui &lt;- dashboardPage( skin = &quot;purple&quot;, ) Cabecera con logo y titulo: Primero vamos a editar el dashboardHeader(), para incluir nuestro logo (que debemos tener guardado en la carpeta www) y el título. Dentro del dashboardPage() debemos pegar el siguiente codigo: Code # 1. Cabecera del Dashboard dashboardHeader( title = tagList( # Usamos tags$img para añadir la imagen del logo tags$img(src = &#39;heart-pulse.svg&#39;, height = &#39;45&#39;, style = &quot;padding-right:10px;&quot;), # Título de la App como texto simple &quot;Análisis de enfermedades cardíacas&quot; ), titleWidth = 450 ), Las pestañas de navegación: Dentro de dashboardSidebar(), usamos sidebarMenu() para crear nuestra navegación. Cada menuItem() representa un botón en el menú. text: El texto visible. tabName: Un ID interno que usaremos para conectar el botón con su contenido. icon: Un pequeño ícono para darle un toque visual. Dentro del dashboardPage() y seguido al codigo de dashboardHeader(), incluimos el siguiente codigo para la barra de navegación: Code # 2. Barra Lateral de Navegación dashboardSidebar( width = 450, sidebarMenu( menuItem(&quot;Análisis Exploratorio&quot;, tabName = &quot;eda&quot;, icon = icon(&quot;chart-bar&quot;)), menuItem(&quot;Entrenamiento del Modelo&quot;, tabName = &quot;entrenamiento&quot;, icon = icon(&quot;gears&quot;)), menuItem(&quot;Predicciones&quot;, tabName = &quot;predicciones&quot;, icon = icon(&quot;laptop&quot;)) ) ), Contenido de cada pestaña (Body): Finalmente, en dashboardBody(), usamos tabItems() para definir el contenido de cada pestaña. Cada tabItem() corresponde a un menuItem de los creados en el paso anterior, y se conectan a través del ID que definimos en tabName. Dentro del dashboardPage() y seguido al codigo de dashboardSidebar(), incluimos el siguiente codigo para la barra de navegación: Code # 3. Cuerpo del Dashboard dashboardBody( # --- CSS para centrar el contenido de las valueBox --- tags$head( tags$style(HTML(&quot; .small-box .inner { text-align: center; } .small-box h3, .small-box p { text-align: center; } &quot;)) ), tabItems( # Contenido de la Pestaña 1: Análisis Exploratorio tabItem(tabName = &quot;eda&quot;, h2(&quot;Análisis Exploratorio de Datos&quot;) ), # Contenido de la Pestaña 2: Entrenamiento tabItem(tabName = &quot;entrenamiento&quot;, h2(&quot;Entrenamiento de un Modelo Predictivo&quot;) ), # Contenido de la Pestaña 3: Predicciones tabItem(tabName = &quot;predicciones&quot;, h2(&quot;Realizar una Predicción&quot;) ) ) ) Guarda todos tus archivos y haz clic en “Run App”. ️ Resultado de esta tarea Code # --- Archivo: ui.R --- library(shinydashboard) # Define la UI (Interfaz de Usuario) ui &lt;- dashboardPage(skin = &quot;purple&quot;, # 1. Cabecera del Dashboard dashboardHeader( title = tagList( # Usamos tags$img para añadir la imagen del logo tags$img(src = &#39;heart-pulse.svg&#39;, height = &#39;45&#39;, style = &quot;padding-right:10px;&quot;), # Título de la App como texto simple &quot;Análisis de enfermedades cardíacas&quot; ), titleWidth = 450 ), # 2. Barra Lateral de Navegación dashboardSidebar( width = 450, sidebarMenu( menuItem(&quot;Análisis Exploratorio&quot;, tabName = &quot;eda&quot;, icon = icon(&quot;chart-bar&quot;)), menuItem(&quot;Entrenamiento del Modelo&quot;, tabName = &quot;entrenamiento&quot;, icon = icon(&quot;gears&quot;)), menuItem(&quot;Predicciones&quot;, tabName = &quot;predicciones&quot;, icon = icon(&quot;laptop&quot;)) ) ), # 3. Cuerpo del Dashboard dashboardBody( # --- CSS para centrar el contenido de las valueBox --- tags$head( tags$style(HTML(&quot; .small-box .inner { text-align: center; } .small-box h3, .small-box p { text-align: center; } &quot;)) ), tabItems( # Contenido de la Pestaña 1: Análisis Exploratorio tabItem(tabName = &quot;eda&quot;, h2(&quot;Análisis Exploratorio de Datos&quot;) ), # Contenido de la Pestaña 2: Entrenamiento tabItem(tabName = &quot;entrenamiento&quot;, h2(&quot;Entrenamiento de un Modelo Predictivo&quot;) ), # Contenido de la Pestaña 3: Predicciones tabItem(tabName = &quot;predicciones&quot;, h2(&quot;Realizar una Predicción&quot;) ) ) ) ) Por ahora el archivo server.R sigue vacio. 7.2.6 Tarea 5: Definir la ui de la exploración de datos En esta tarea vamos a crear la primera pestaña de la aplicación, la pestaña de Análisis exploratorio de datos (EDA). Al final de este módulo, se tendrán gráficos y tablas que reaccionan instantáneamente a las selecciones del usuario. Aquí es donde nuestro archivo server.R, hasta ahora vacío, entra en acción. Ahora se va a definir los elementos que el usuario verá en la pestaña del EDA. Los elementos principales para organizar el contendio serán box(), para organizar la información en cajas, y fluidRow() para organizar la información en filas. En la pestaña de EDA, organizamos la interfaz en tres filas principales (fluidRow). Cada una tiene un propósito específico: Primera fluidRow: La fila de resumen (con los valueBox) Esta será la fila superior que contiene las cuatro cajas de colores con los números clave (Observaciones, Variables, etc.). Actúa como un “panel de vitales” para nuestro dataset. Su objetivo es dar al usuario una visión general e instantánea de los datos con los que está trabajando, incluso antes de empezar a explorarlos en detalle. Code # Fila de Cajas con Métricas (Value Boxes) fluidRow(box(width = 12, title = &quot;Resumen del Dataset&quot;, status = &quot;primary&quot;, solidHeader = TRUE, collapsible = TRUE, fluidRow( column(3, valueBox(nrow(df), &quot;Observaciones&quot;, width = 12, color=&quot;navy&quot;)), column(3, valueBox(ncol(df), &quot;Variables&quot;, width = 12, color=&quot;navy&quot;)), column(3, valueBox(paste0(round(sum(df$EnfermedadCorazon == &quot;Sí&quot;) / nrow(df) * 100), &quot;%&quot;), &quot;% con Enfermedad&quot;, width = 12, color=&quot;navy&quot;)), column(3, valueBox(sum(is.na(df)), &quot;Valores Faltantes&quot;, width = 12, color=&quot;navy&quot;)) ) ) ), Segunda fluidRow: El centro de mando interactivo Esta es la fila central que contiene la caja de controles a la izquierda (menús desplegables, sliders) y la caja del gráfico a la derecha. Esta es el corazón de la interactividad. A la izquierda, le damos al usuario las “palancas y botones” para hacer preguntas a los datos. A la derecha, le mostramos la respuesta a esas preguntas de forma visual. Es la manifestación más clara de la conexión entre input y output. Code fluidRow(box( title = &quot;Configuración de Gráficos&quot;, status = &quot;primary&quot;, solidHeader = TRUE, width = 4, # Selector para el tipo de gráfico selectInput(&quot;plot_type&quot;, &quot;Selecciona un tipo de gráfico:&quot;, choices = c(&quot;Histograma / Gráfico de Barras&quot;, &quot;Gráfico de Cajas (Box Plot)&quot;)), selectInput(&quot;variable&quot;, &quot;Selecciona una variable:&quot;, choices = c(&quot;Edad&quot; = &quot;Age&quot;, &quot;Sexo&quot; = &quot;Sex&quot;, &quot;Tipo de Dolor de Pecho&quot; = &quot;ChestPainType&quot;, &quot;Nivel de Colesterol&quot; = &quot;Cholesterol&quot;, &quot;Frecuencia Cardíaca Máxima&quot; = &quot;MaxHR&quot;)), sliderInput(&quot;rango_edad&quot;, &quot;Filtra por Rango de Edad:&quot;, min = min(df$Age), max = max(df$Age), value = c(min(df$Age), max(df$Age)))), box(title = &quot;Gráfico Interactivo&quot;, status = &quot;success&quot;, solidHeader = TRUE, width = 8, # Usamos plotlyOutput en lugar de plotOutput plotlyOutput(&quot;distPlot&quot;)) ), Tercera fluidRow: La vista detallada (con la dataTable) Esta es la última fila que contiene la tabla de datos interactiva. Funciona como una “lupa”. Mientras que el gráfico nos da una visión agregada y visual, la tabla nos permite inspeccionar las filas de datos individuales que componen ese gráfico. Permite buscar, ordenar y verificar los datos crudos, ofreciendo un nivel de detalle que el gráfico no puede. Code # Fila para la Tabla de Datos fluidRow(box( title = &quot;Tabla de Datos&quot;, status = &quot;info&quot;, solidHeader = TRUE, width = 12, DT::dataTableOutput(&quot;tablaDatos&quot;) ) ) ️ Resultado de esta tarea Code # Contenido de la Pestaña 1: Análisis Exploratorio tabItem(tabName = &quot;eda&quot;, h2(&quot;Análisis Exploratorio de Datos&quot;), # Fila de Cajas con Métricas (Value Boxes) fluidRow( box( width = 12, title = &quot;Resumen del Dataset&quot;, status = &quot;primary&quot;, solidHeader = TRUE, collapsible = TRUE, fluidRow( column(3, valueBox(nrow(df), &quot;Observaciones&quot;, width = 12, color=&quot;navy&quot;)), column(3, valueBox(ncol(df), &quot;Variables&quot;, width = 12, color=&quot;navy&quot;)), column(3, valueBox(paste0(round(sum(df$EnfermedadCorazon == &quot;Sí&quot;) / nrow(df) * 100), &quot;%&quot;), &quot;% con Enfermedad&quot;, width = 12, color=&quot;navy&quot;)), column(3, valueBox(sum(is.na(df)), &quot;Valores Faltantes&quot;, width = 12, color=&quot;navy&quot;)) ) ) ), # Fila con Controles y Gráfico fluidRow( # Caja de Controles box( title = &quot;Configuración de Gráficos&quot;, status = &quot;primary&quot;, solidHeader = TRUE, width = 4, selectInput(&quot;variable&quot;, &quot;Selecciona una variable:&quot;, choices = c( &quot;Edad&quot; = &quot;Age&quot;, &quot;Sexo&quot; = &quot;Sex&quot;, &quot;Tipo de Dolor de Pecho&quot; = &quot;ChestPainType&quot;, &quot;Nivel de Colesterol&quot; = &quot;Cholesterol&quot;, &quot;Frecuencia Cardíaca Máxima&quot; = &quot;MaxHR&quot; ) ), sliderInput(&quot;rango_edad&quot;, &quot;Filtra por Rango de Edad:&quot;, min = min(df$Age), max = max(df$Age), value = c(min(df$Age), max(df$Age))) ), # Caja para el Gráfico box( title = &quot;Gráfico Interactivo&quot;, status = &quot;success&quot;, solidHeader = TRUE, width = 8, # Usamos plotlyOutput para un gráfico interactivo plotlyOutput(&quot;distPlot&quot;) ) ), # Fila para la Tabla de Datos fluidRow( box( title = &quot;Tabla de Datos&quot;, status = &quot;info&quot;, solidHeader = TRUE, width = 12, DT::dataTableOutput(&quot;tablaDatos&quot;) ) ) ), 7.2.7 Tarea 6: Lógica del server para la exploración de datos En esta tarea, usaremos el archivo server.R para indicarle a shiny como debe reaccionar la aplicación antes los cambios en los selectInput y sliderInput creados en la interfaz de usuario. Inicialmente debes asegurarnos que nuestro archivo server.R tenga la siguiente estructura basica: Code # Define el servidor (lógica del back-end) server &lt;- function(input, output, session) { } En esta parte vamos a implementar los tres elementos principales de nuestra pestaña de EDA: El filtro reactivo: datos_filtrados &lt;- reactive({...}) Es una expresión reactiva cuya única misión es observar el slider de edad (input$rango_edad). En cuanto el usuario mueve el slider, esta expresión se re-ejecuta, filtra el dataframe original y produce una nueva versión actualizada. Es la fuente central de datos para todos los demás elementos de la pestaña, lo que hace el código muy eficiente. Code # 1. Creamos un set de datos reactivo que se filtra por el rango de edad datos_filtrados &lt;- reactive({ df %&gt;% filter(Age &gt;= input$rango_edad[1] &amp; Age &lt;= input$rango_edad[2]) }) El graficador: output$distPlot &lt;- renderPlotly({...}) Esta es la función que renderiza (dibuja) el gráfico. Este bloque escucha dos cosas: al filtro reactivo (datos_filtrados) y las instrucciones del usuario sobre qué variable dibujar (input$variable). Cuando cualquiera de los dos cambia, el graficador toma los nuevos datos y las nuevas instrucciones, dibuja un ggplot, y se lo pasa a ggplotly para que le añada la interactividad antes de enviarlo a la interfaz de usuario. Code # 2. Creamos el gráfico de distribución output$distPlot &lt;- renderPlotly({ variable_seleccionada &lt;- input$variable # Lógica para seleccionar el tipo de gráfico if (input$plot_type == &quot;Histograma / Gráfico de Barras&quot;) { # Si la variable es categórica (factor), crea un gráfico de barras if (is.factor(datos_filtrados()[[variable_seleccionada]])) { p &lt;- datos_filtrados() %&gt;% ggplot(aes(x = .data[[variable_seleccionada]], fill = EnfermedadCorazon)) + geom_bar(position = &quot;fill&quot;) + labs(y = &quot;Proporción&quot;, title = paste(&quot;Proporción de Enfermedad Cardíaca por&quot;, variable_seleccionada)) + theme_minimal() } else { # Si es numérica, crea un histograma p &lt;- datos_filtrados() %&gt;% ggplot(aes(x = .data[[variable_seleccionada]], fill = EnfermedadCorazon)) + geom_histogram(binwidth = 5, alpha = 0.7, position = &quot;identity&quot;) + labs(title = paste(&quot;Distribución de&quot;, variable_seleccionada)) + theme_minimal() } } else { # Lógica para el &quot;Gráfico de Cajas (Box Plot)&quot; # Si la variable es categórica, muestra la distribución de Edad para cada categoría if (is.factor(datos_filtrados()[[variable_seleccionada]])) { p &lt;- datos_filtrados() %&gt;% ggplot(aes(x = .data[[variable_seleccionada]], y = Age, fill = .data[[variable_seleccionada]])) + geom_boxplot(show.legend = FALSE) + labs(title = paste(&quot;Distribución de Edad por&quot;, variable_seleccionada)) + theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) } else { # Si la variable es numérica, muestra su distribución general p &lt;- datos_filtrados() %&gt;% ggplot(aes(x = EnfermedadCorazon, y = .data[[variable_seleccionada]], fill = EnfermedadCorazon)) + geom_boxplot(show.legend = FALSE) + labs(title = paste(&quot;Distribución de&quot;, variable_seleccionada, &quot;por Diagnóstico&quot;)) + theme_minimal() } } # Convierte el gráfico ggplot a plotly para hacerlo interactivo ggplotly(p) }) El organizador de datos: output$tablaDatos &lt;- DT::renderDataTable({...}) Esta es la función que renderiza la tabla de datos. El proposito de este bloque es ser el “organizador”. Su trabajo es más simple: solo escucha a la “expresión reactiva” (datos_filtrados). Cuando los datos filtrados cambian, este bloque los toma, selecciona las columnas más importantes para mantener la tabla limpia, y la presenta en un formato interactivo, con paginación y opción de búsqueda, en la interfaz de usuario. Code # 3. Creamos la tabla de datos output$tablaDatos &lt;- DT::renderDataTable({ datos_filtrados() %&gt;% select(Age, Sex, ChestPainType, Cholesterol, EnfermedadCorazon) }, options = list(pageLength = 10)) ️ Resultado de esta tarea Code # --- Archivo: server.R --- # Define el servidor (lógica del back-end) server &lt;- function(input, output, session) { # --- Pestaña 1: Lógica del Análisis Exploratorio --- # 1. Creamos un set de datos reactivo que se filtra por el rango de edad datos_filtrados &lt;- reactive({ df %&gt;% filter(Age &gt;= input$rango_edad[1] &amp; Age &lt;= input$rango_edad[2]) }) # 2. Creamos el gráfico de distribución output$distPlot &lt;- renderPlotly({ variable_seleccionada &lt;- input$variable # Lógica para seleccionar el tipo de gráfico if (input$plot_type == &quot;Histograma / Gráfico de Barras&quot;) { # Si la variable es categórica (factor), crea un gráfico de barras if (is.factor(datos_filtrados()[[variable_seleccionada]])) { p &lt;- datos_filtrados() %&gt;% ggplot(aes(x = .data[[variable_seleccionada]], fill = EnfermedadCorazon)) + geom_bar(position = &quot;fill&quot;) + labs(y = &quot;Proporción&quot;, title = paste(&quot;Proporción de Enfermedad Cardíaca por&quot;, variable_seleccionada)) + theme_minimal() } else { # Si es numérica, crea un histograma p &lt;- datos_filtrados() %&gt;% ggplot(aes(x = .data[[variable_seleccionada]], fill = EnfermedadCorazon)) + geom_histogram(binwidth = 5, alpha = 0.7, position = &quot;identity&quot;) + labs(title = paste(&quot;Distribución de&quot;, variable_seleccionada)) + theme_minimal() } } else { # Lógica para el &quot;Gráfico de Cajas (Box Plot)&quot; # Si la variable es categórica, muestra la distribución de Edad para cada categoría if (is.factor(datos_filtrados()[[variable_seleccionada]])) { p &lt;- datos_filtrados() %&gt;% ggplot(aes(x = .data[[variable_seleccionada]], y = Age, fill = .data[[variable_seleccionada]])) + geom_boxplot(show.legend = FALSE) + labs(title = paste(&quot;Distribución de Edad por&quot;, variable_seleccionada)) + theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) } else { # Si la variable es numérica, muestra su distribución general p &lt;- datos_filtrados() %&gt;% ggplot(aes(x = EnfermedadCorazon, y = .data[[variable_seleccionada]], fill = EnfermedadCorazon)) + geom_boxplot(show.legend = FALSE) + labs(title = paste(&quot;Distribución de&quot;, variable_seleccionada, &quot;por Diagnóstico&quot;)) + theme_minimal() } } # Convierte el gráfico ggplot a plotly para hacerlo interactivo ggplotly(p) }) # 3. Creamos la tabla de datos output$tablaDatos &lt;- DT::renderDataTable({ datos_filtrados() %&gt;% select(Age, Sex, ChestPainType, Cholesterol, EnfermedadCorazon) }, options = list(pageLength = 10)) } Guarda ambos archivos (ui.R y server.R) y ejecuta la aplicación. 7.2.8 Tarea 7: La interfaz del entrenador en ui.R En este módulo, construiremos la pestaña de “Entrenamiento del Modelo”. El usuario podrá elegir un algoritmo, decidir cómo dividir los datos y, con un solo clic, entrenar un modelo y ver su rendimiento a través de métricas y gráficos avanzados. En esta tarea vamos diseñar la interfaz de esta pestaña. Necesitaremos una caja para los controles (el tipo de modelo, el porcentaje de división) y una caja más grande para mostrar los resultados (métricas, matriz de confusión y curva ROC). ️ Resultado de esta tarea Code # Contenido de la Pestaña 2: Entrenamiento tabItem(tabName = &quot;entrenamiento&quot;, h2(&quot;Entrenamiento de un Modelo Predictivo&quot;), fluidRow( # Caja de control box( title = &quot;Control de Entrenamiento&quot;, status = &quot;primary&quot;, solidHeader = TRUE, width = 4, selectInput(&quot;modelo_seleccionado&quot;, &quot;Selecciona un Modelo:&quot;, choices = c( &quot;Regresión Logística&quot; = &quot;glm&quot;, &quot;Bosque Aleatorio (Random Forest)&quot; = &quot;rf&quot; )), sliderInput(&quot;train_split_percentage&quot;, &quot;Porcentaje de Datos para Entrenamiento:&quot;, min = 50, max = 90, value = 80, step = 5, post = &quot;%&quot;), actionButton(&quot;entrenarModelo&quot;, &quot;Entrenar Modelo&quot;, class = &quot;btn-success&quot;, icon = icon(&quot;play&quot;)), helpText(&quot;Presiona el botón para entrenar el modelo seleccionado y ver sus métricas de rendimiento.&quot;) ), # Caja de resultados box( title = &quot;Resultados del Modelo&quot;, status = &quot;info&quot;, solidHeader = TRUE, width = 8, collapsible = TRUE, # Fila para las métricas de texto fluidRow( column(width = 12, h4(&quot;Métricas Principales&quot;), verbatimTextOutput(&quot;metricas_modelo&quot;) ) ), # Fila para los gráficos, uno al lado del otro fluidRow( column(width = 6, h4(&quot;Matriz de Confusión&quot;), plotlyOutput(&quot;heatmap_confusion&quot;) ), column(width = 6, h4(&quot;Curva ROC&quot;), plotlyOutput(&quot;curva_roc&quot;) ) ) ) ) ), 7.2.9 Tarea 8: Logica del server para el entrenamiento En esta tarea es donde ocurre la magia del Machine Learning. Usaremos una función especial, observeEvent, para que el código solo se ejecute cuando el usuario haga clic en el botón “Entrenar Modelo”. Pensemos en el observeEvent como un “guardia” que vigila el botón input$entrenarModelo. El guardia no hace absolutamente nada hasta que se presiona el botón. En ese momento, cobra vida y ejecuta toda la secuencia de comandos que le indiquemos. Mas información sobre observeEvent aqui: Link documentación Nota: Es importante añadir el reactiveValues(modelo = NULL) al inicio del server para tener un lugar donde guardar el modelo que entrenemos. ️ Resultado de esta tarea Code # --- Pestaña 2: Lógica de Entrenamiento del Modelo --- # Usamos reactiveValues para almacenar el modelo entrenado y usarlo en la otra pestaña valores_reactivos &lt;- reactiveValues(modelo = NULL) # Almacena el modelo entrenado en valores_reactivos al presionar el botón observeEvent(input$entrenarModelo, { withProgress(message = &#39;Entrenando modelo...&#39;, detail = &#39;Esto puede tomar un momento...&#39;, { # 1. Preparación de datos set.seed(42) particion &lt;- createDataPartition(df$EnfermedadCorazon, p = input$train_split_percentage / 100, # Usa el input del slider list = FALSE) datos_entrenamiento &lt;- df[particion, ] datos_prueba &lt;- df[-particion, ] # 2. Entrenamiento del modelo seleccionado por el usuario modelo &lt;- train(EnfermedadCorazon ~ ., data = datos_entrenamiento, method = input$modelo_seleccionado, # Usa el input del usuario family = &quot;binomial&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 5, classProbs = TRUE, summaryFunction = twoClassSummary), metric = &quot;ROC&quot;) # Almacena el modelo para la pestaña de predicciones valores_reactivos$modelo &lt;- modelo # 3. Generación de predicciones y matriz de confusión predicciones_clase &lt;- predict(modelo, newdata = datos_prueba) matriz_confusion &lt;- confusionMatrix(predicciones_clase, datos_prueba$EnfermedadCorazon, positive = &quot;Sí&quot;) # --- Creación de las salidas --- # Salida 1: Métricas principales en texto output$metricas_modelo &lt;- renderPrint({ cat(&quot;Métricas Generales:\\n&quot;) print(matriz_confusion$overall[c(&quot;Accuracy&quot;, &quot;Kappa&quot;)]) cat(&quot;\\nMétricas por Clase (Clase Positiva: &#39;Sí&#39;):\\n&quot;) print(matriz_confusion$byClass[c(&quot;Sensitivity&quot;, &quot;Specificity&quot;, &quot;Precision&quot;, &quot;Recall&quot;, &quot;F1&quot;)]) }) # Salida 2: Heatmap interactivo para la Matriz de Confusión output$heatmap_confusion &lt;- renderPlotly({ matriz &lt;- as.data.frame(matriz_confusion$table) p &lt;- ggplot(matriz, aes(x = Prediction, y = Reference, fill = Freq)) + geom_tile() + geom_text(aes(label = Freq), color = &quot;white&quot;, size = 6) + scale_fill_gradient(low = &quot;#5DADE2&quot;, high = &quot;#1B4F72&quot;) + labs(title = &quot;Matriz de Confusión&quot;, x = &quot;Clase Predicha&quot;, y = &quot;Clase Real&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;) ggplotly(p) }) # Salida 3: Curva ROC interactiva output$curva_roc &lt;- renderPlotly({ predicciones_prob &lt;- predict(modelo, newdata = datos_prueba, type = &quot;prob&quot;) # Calcular la curva ROC roc_obj &lt;- roc(response = datos_prueba$EnfermedadCorazon, predictor = predicciones_prob$Sí, levels = c(&quot;No&quot;, &quot;Sí&quot;)) # Graficar la curva ROC p &lt;- ggroc(roc_obj, legacy.axes = TRUE) + geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color = &quot;grey&quot;, linetype = &quot;dashed&quot;) + labs(title = paste(&quot;Curva ROC (AUC =&quot;, round(auc(roc_obj), 3), &quot;)&quot;), x = &quot;Tasa de Falsos Positivos (1 - Especificidad)&quot;, y = &quot;Tasa de Verdaderos Positivos (Sensibilidad)&quot;) + theme_minimal() ggplotly(p) }) }) # Fin de withProgress }) # Fin de observeEvent Guarda ambos archivos (ui.R y server.R) y ejecuta la aplicación. 7.2.10 Tarea 9: La Interfaz de predicción Aqui vamos a construir la última pieza de nuestra aplicación: la pestaña de “Predicciones”. Crearemos un formulario donde el usuario podrá introducir los datos de un paciente y, al instante, obtener una predicción sobre su riesgo cardíaco, presentada de una forma visual, clara e informativa. En esta tarea, primero diseñaremos el formulario en ui.R. Necesitaremos un slider o selector para cada una de las 11 características de nuestro modelo. A la derecha, dejaremos espacios (uiOutput y plotlyOutput) para nuestros resultados dinámicos. En el archivo ui.R vamos a llenar el contenido de la tercera pestaña (tabItem(tabName = \"predicciones\", ...)). ️ Resultado de esta tarea Code # Contenido de la Pestaña 3: Predicciones tabItem(tabName = &quot;predicciones&quot;, h2(&quot;Realizar una Predicción&quot;), fluidRow( # Caja de Atributos box( title = &quot;Ingresa los datos del paciente:&quot;, status = &quot;primary&quot;, solidHeader = TRUE, width = 4, h4(&quot;Cargar Pacientes de Ejemplo:&quot;), fluidRow( column(6, actionButton(&quot;cargar_paciente_riesgo&quot;, &quot;Alto Riesgo&quot;, class = &quot;btn-danger&quot;, width = &#39;100%&#39;)), column(6, actionButton(&quot;cargar_paciente_normal&quot;, &quot;Bajo Riesgo&quot;, class = &quot;btn-success&quot;, width = &#39;100%&#39;)) ), hr(), # Separador visual # Inputs para los datos del paciente (sin cambios) sliderInput(&quot;pred_Age&quot;, &quot;Edad:&quot;, min = 28, max = 77, value = 50), selectInput(&quot;pred_Sex&quot;, &quot;Sexo:&quot;, choices = c(&quot;M&quot;, &quot;F&quot;)), selectInput(&quot;pred_ChestPainType&quot;, &quot;Tipo de Dolor de Pecho:&quot;, choices = c(&quot;ASY&quot;, &quot;ATA&quot;, &quot;NAP&quot;, &quot;TA&quot;)), sliderInput(&quot;pred_RestingBP&quot;, &quot;Presión Arterial en Reposo (mm Hg):&quot;, min = 80, max = 200, value = 120), sliderInput(&quot;pred_Cholesterol&quot;, &quot;Colesterol (mm/dl):&quot;, min = 0, max = 603, value = 200), selectInput(&quot;pred_FastingBS&quot;, &quot;Azúcar en Sangre en Ayunas (&gt; 120 mg/dl):&quot;, choices = c(&quot;0&quot;, &quot;1&quot;)), selectInput(&quot;pred_RestingECG&quot;, &quot;Resultados de Electrocardiograma:&quot;, choices = c(&quot;Normal&quot;, &quot;ST&quot;, &quot;LVH&quot;)), sliderInput(&quot;pred_MaxHR&quot;, &quot;Frecuencia Cardíaca Máxima:&quot;, min = 60, max = 202, value = 150), selectInput(&quot;pred_ExerciseAngina&quot;, &quot;Angina Inducida por Ejercicio:&quot;, choices = c(&quot;Y&quot;, &quot;N&quot;)), sliderInput(&quot;pred_Oldpeak&quot;, &quot;Oldpeak (Depresión del ST):&quot;, min = -2.6, max = 6.2, value = 1), selectInput(&quot;pred_ST_Slope&quot;, &quot;Pendiente del Segmento ST:&quot;, choices = c(&quot;Up&quot;, &quot;Flat&quot;, &quot;Down&quot;)), actionButton(&quot;predecir&quot;, &quot;Predecir&quot;, class = &quot;btn-primary btn-lg&quot;, icon = icon(&quot;chart-line&quot;), width = &#39;100%&#39;) ), # Caja de Resultados box( title = &quot;Resultado de la Predicción&quot;, status = &quot;success&quot;, solidHeader = TRUE, width = 8, # Salida para el infoBox dinámico uiOutput(&quot;resultado_pred_box&quot;), hr(), # Separador visual # Salida para el gráfico de contexto h4(&quot;Contexto de los Datos Ingresados&quot;), plotlyOutput(&quot;contexto_plot&quot;) ) ) ) 7.2.11 Tarea 10: La lógica de predicción en server.R En esta tarea usaremos eventReactive, que es un primo de observeEvent. Mas información sobre eventReactive aqui: Link documentación Piensa que si observeEvent es un “guardia” que hace cosas, eventReactive es un “científico cauteloso”. El científico recoge todos los ingredientes (los 11 inputs), pero solo ejecuta el experimento (la predicción) cuando se presiona el botón “Predecir”. El resultado del experimento se guarda y puede ser usado por múltiples salidas. ️ Resultado de esta tarea Code # --- Pestaña 3: Predicciones --- observeEvent(input$cargar_paciente_riesgo, { # Paciente de ejemplo con enfermedad (fila 916 del dataset) paciente &lt;- df[916, ] updateSliderInput(session, &quot;pred_Age&quot;, value = paciente$Age) updateSelectInput(session, &quot;pred_Sex&quot;, selected = paciente$Sex) updateSelectInput(session, &quot;pred_ChestPainType&quot;, selected = paciente$ChestPainType) updateSliderInput(session, &quot;pred_RestingBP&quot;, value = paciente$RestingBP) updateSliderInput(session, &quot;pred_Cholesterol&quot;, value = paciente$Cholesterol) updateSelectInput(session, &quot;pred_FastingBS&quot;, selected = paciente$FastingBS) updateSelectInput(session, &quot;pred_RestingECG&quot;, selected = paciente$RestingECG) updateSliderInput(session, &quot;pred_MaxHR&quot;, value = paciente$MaxHR) updateSelectInput(session, &quot;pred_ExerciseAngina&quot;, selected = paciente$ExerciseAngina) updateSliderInput(session, &quot;pred_Oldpeak&quot;, value = paciente$Oldpeak) updateSelectInput(session, &quot;pred_ST_Slope&quot;, selected = paciente$ST_Slope) }) # Lógica para cargar paciente de BAJO RIESGO de ejemplo observeEvent(input$cargar_paciente_normal, { # Paciente de ejemplo sin enfermedad (fila 1 del dataset) paciente &lt;- df[1, ] updateSliderInput(session, &quot;pred_Age&quot;, value = paciente$Age) updateSelectInput(session, &quot;pred_Sex&quot;, selected = paciente$Sex) updateSelectInput(session, &quot;pred_ChestPainType&quot;, selected = paciente$ChestPainType) updateSliderInput(session, &quot;pred_RestingBP&quot;, value = paciente$RestingBP) updateSliderInput(session, &quot;pred_Cholesterol&quot;, value = paciente$Cholesterol) updateSelectInput(session, &quot;pred_FastingBS&quot;, selected = paciente$FastingBS) updateSelectInput(session, &quot;pred_RestingECG&quot;, selected = paciente$RestingECG) updateSliderInput(session, &quot;pred_MaxHR&quot;, value = paciente$MaxHR) updateSelectInput(session, &quot;pred_ExerciseAngina&quot;, selected = paciente$ExerciseAngina) updateSliderInput(session, &quot;pred_Oldpeak&quot;, value = paciente$Oldpeak) updateSelectInput(session, &quot;pred_ST_Slope&quot;, selected = paciente$ST_Slope) }) # Reactivo que se activa al presionar el botón &quot;Predecir&quot; (lógica interna sin cambios) prediccion_hecha &lt;- eventReactive(input$predecir, { req(valores_reactivos$modelo) datos_nuevos &lt;- data.frame( Age = as.numeric(input$pred_Age), Sex = factor(input$pred_Sex, levels = levels(df$Sex)), ChestPainType = factor(input$pred_ChestPainType, levels = levels(df$ChestPainType)), RestingBP = as.numeric(input$pred_RestingBP), Cholesterol = as.numeric(input$pred_Cholesterol), FastingBS = factor(input$pred_FastingBS, levels = levels(df$FastingBS)), RestingECG = factor(input$pred_RestingECG, levels = levels(df$RestingECG)), MaxHR = as.numeric(input$pred_MaxHR), ExerciseAngina = factor(input$pred_ExerciseAngina, levels = levels(df$ExerciseAngina)), Oldpeak = as.numeric(input$pred_Oldpeak), ST_Slope = factor(input$pred_ST_Slope, levels = levels(df$ST_Slope)) ) prediccion &lt;- predict(valores_reactivos$modelo, newdata = datos_nuevos, type = &quot;raw&quot;) probabilidad &lt;- predict(valores_reactivos$modelo, newdata = datos_nuevos, type = &quot;prob&quot;) # Devuelve una lista con la predicción, probabilidad y los datos ingresados list(pred = prediccion, prob = probabilidad, datos = datos_nuevos) }) # Salida para el infoBox dinámico output$resultado_pred_box &lt;- renderUI({ # Requiere que se haya hecho una predicción req(prediccion_hecha()) res &lt;- prediccion_hecha() prob_si &lt;- round(res$prob$&#39;Sí&#39; * 100, 1) if (res$pred == &quot;Sí&quot;) { infoBox( title = &quot;Resultado: Alto Riesgo&quot;, value = paste0(prob_si, &quot;% de probabilidad de enfermedad&quot;), icon = icon(&quot;triangle-exclamation&quot;), color = &quot;red&quot;, width = 12, fill = TRUE ) } else { infoBox( title = &quot;Resultado: Bajo Riesgo&quot;, value = paste0(prob_si, &quot;% de probabilidad de enfermedad&quot;), icon = icon(&quot;check-circle&quot;), color = &quot;green&quot;, width = 12, fill = TRUE ) } }) # Salida para el gráfico de contexto output$contexto_plot &lt;- renderPlotly({ req(prediccion_hecha()) res &lt;- prediccion_hecha() # Variables numéricas clave para comparar vars_numericas &lt;- c(&quot;Age&quot;, &quot;RestingBP&quot;, &quot;Cholesterol&quot;, &quot;MaxHR&quot;) # Calcular promedios promedios &lt;- df %&gt;% select(all_of(vars_numericas), EnfermedadCorazon) %&gt;% group_by(EnfermedadCorazon) %&gt;% summarise(across(everything(), mean)) %&gt;% pivot_longer(-EnfermedadCorazon, names_to = &quot;Variable&quot;, values_to = &quot;Valor&quot;) # Datos del paciente ingresado datos_paciente &lt;- res$datos %&gt;% select(all_of(vars_numericas)) %&gt;% pivot_longer(everything(), names_to = &quot;Variable&quot;, values_to = &quot;Valor&quot;) %&gt;% mutate(EnfermedadCorazon = &quot;Paciente Actual&quot;) # Combinar datos datos_plot &lt;- bind_rows(promedios, datos_paciente) # Crear gráfico p &lt;- ggplot(datos_plot, aes(x = Variable, y = Valor, fill = EnfermedadCorazon)) + geom_col(position = &quot;dodge&quot;) + scale_fill_manual(values = c(&quot;Sí&quot; = &quot;#E74C3C&quot;, &quot;No&quot; = &quot;#2ECC71&quot;, &quot;Paciente Actual&quot; = &quot;#3498DB&quot;)) + labs(title = &quot;Comparación con Valores Promedio&quot;, y = &quot;Valor&quot;, x = &quot;&quot;, fill = &quot;Grupo&quot;) + theme_minimal() + coord_flip() # Girar coordenadas para mejor lectura ggplotly(p) }) Guarda ambos archivos (ui.R y server.R) y ejecuta la aplicación. 7.3 Ejercicios practicos Ahora es tu turno de personalizar y llevar mas alla la aplicación construida. 7.3.1 Desafío 1 (Fácil): ¡Dale tu estilo! Misión: La aplicación usa un tema de color púrpura (skin = 'purple'). Investiga qué otros skins están disponibles en shinydashboard y personaliza la aplicación con el color que más te guste. ¿Por qué es importante? Aprender a personalizar la apariencia de tu app es el primer paso para hacerla tuya y adaptarla a diferentes necesidades o marcas. Pistas Clave Busca la función dashboardPage() en tu archivo ui.R. El argumento que controla el color es skin. Prueba con otros colores como \"blue\", \"black\", \"green\", \"yellow\", o \"red\". 7.3.2 Desafío 2 (Intermedio): Pacientes de ejemplo Misión: Rellenar los 11 campos en la pestaña de predicción cada vez es lento. Añade dos botones: “Cargar Paciente de Alto Riesgo” y “Cargar Paciente de Bajo Riesgo” que rellenen automáticamente los campos. ¿Por qué es importante? Aprenderás a controlar la interfaz de usuario desde el servidor. Esta es una de las técnicas más poderosas de Shiny, ya que te permite crear guías y atajos para tus usuarios. Pistas Clave Añade dos actionButton() a tu ui.R en la caja de controles de predicción. En server.R, necesitarás crear dos nuevos bloques observeEvent, uno para cada botón. Dentro de cada observeEvent, busca una fila en el dataframe df que cumpla la condición. Luego, usa la familia de funciones updateSliderInput() y updateSelectInput() para actualizar cada uno de los 11 campos. 7.3.3 Desafío 3 (Avanzado): ¡Guarda tu modelo! Misión: El modelo que entrenas se pierde cada vez que cierras la app. Añade un botón de “Guardar Modelo” en la pestaña de entrenamiento. Al hacer clic, el modelo entrenado debe guardarse como un archivo .rds en el directorio de tu proyecto. ¿Por qué es importante? Esto introduce un concepto clave de MLOps: la persistencia y el versionado de modelos. Separa el proceso de entrenamiento del de predicción, permitiendo que tu app cargue modelos pre-entrenados. Pistas Clave Añade un actionButton(\"guardar_modelo\", ...) a la caja de controles de entrenamiento en ui.R. En server.R, crea un observeEvent que vigile este nuevo botón. Dentro del observeEvent, usa la función saveRDS(). El objeto que quieres guardar está en valores_reactivos$modelo. Puedes darle un nombre dinámico al archivo, como paste0(input$modelo_seleccionado, \"_\", Sys.Date(), \".rds\"). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
