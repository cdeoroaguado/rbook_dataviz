[["tidyverse.html", "Capítulo 2 Tidyverse 2.1 Data Frames 2.2 Importación de datos 2.3 El paquete dplyr", " Capítulo 2 Tidyverse El Tidyverse es un conjunto de paquetes integrados para el lenguaje de programación R, diseñados con el objetivo de facilitar el análisis de datos de manera estructurada, legible y eficiente. Su filosofía se basa en el concepto de “datos ordenados” (tidy data), donde cada variable es una columna, cada observación una fila, y cada tipo de unidad observacional forma una tabla. Estos paquetes comparten principios de diseño comunes y una gramática coherente, lo que permite a los usuarios aprender un conjunto de reglas aplicables en todo el ecosistema, aumentando así la productividad y la claridad del código. Figura 2.1: Paquetes de tidyverse 2.1 Data Frames Definición Un data frame es una estructura de datos clave en estadística y en R. La estructura básica de un data frame es que hay una observación por fila y cada columna representa una variable, medida, rasgo o característica de esa observación. R tiene una implementación interna de los data frames que probablemente es la que más se utiliza en la práctica. 2.2 Importación de datos Fuentes de datos en R Los conjuntos de datos de gran tamaño, generalmente almacenados como data frames en R, suelen provenir de archivos externos. Existen múltiples tipos de archivos que pueden importarse, entre ellos: Archivos de texto en formatos como csv, txt, html y json. Salidas de software estadístico como SAS y SPSS. Recursos en línea como páginas html y servicios web. Bases de datos relacionales y no relacionales. El ecosistema Tidyverse ofrece funciones que permiten importar y gestionar estas diversas fuentes de datos de manera sencilla y eficiente. 2.2.1 Importación de archivos csv con read.table() Definición La función read.table() es una función integrada en R que permite leer archivos de distintos formatos y convertirlos en un data frame. Es una de las funciones más utilizadas para importar archivos simples en R. La sintaxis de read.table() requiere indicar: - Un nombre de archivo (ruta de acceso). - Un valor lógico (TRUE/FALSE) para definir si la primera fila contiene los nombres de las columnas. Si se establece en TRUE, la primera fila se interpreta como encabezado. Si se establece en FALSE, las columnas se importan sin nombres definidos. El resultado de la función siempre es un data frame. Una alternativa práctica es la función file.choose(), que permite seleccionar el archivo de manera interactiva sin necesidad de escribir la ruta manualmente. Observación Pasos para importar un archivo csv con read.table(): Abrir RStudio y dirigirse a la consola. Establecer el directorio de trabajo con código en la consola o desde el menú: Sesión → Establecer directorio de trabajo → Elegir directorio. Ejecutar la función read.table() indicando el archivo csv a importar. Code setwd(&quot;~/Books_CienciaDatos/rbook_dataviz&quot;) Figura 2.2: setwd En la carpeta RDataSets se encuentra el archivo StudyArea.csv, que corresponde a un archivo separado por comas. Este archivo contiene información sobre incendios forestales ocurridos entre los años 1980 y 2016 en distintos estados de EE. UU., entre ellos: California, Oregón, Washington, Idaho, Montana, Wyoming, Colorado, Utah, Nevada, Arizona y Nuevo México. El archivo incluye más de 439000 registros distribuidos en 37 columnas, que describen las características de cada incendio durante ese periodo. Para cargar estos datos en un nuevo objeto data frame, puede utilizarse la función read.table() de la siguiente manera: Code df &lt;- read.table(&quot;data/StudyArea.csv&quot;, header = TRUE) Recibirá un mensaje de error cuando intente ejecutar esta línea de código. El mensaje de error mensaje de error debería aparecer como se ve a continuación Figura 2.3: error en rmd La razón por la que se generó un mensaje de error en este caso es que la función read.table() utiliza espacios como delimitador entre registros y nuestro archivo utiliza comas como delimitador Actualice su llamada a read.table() como se ve a continuación para incluir el argumento sep, que debería ser una coma Code df &lt;- read.table(&quot;data/StudyArea.csv&quot;, sep=&quot;,&quot;, header = TRUE) Cuando ejecute esta línea de código verá un nuevo error Figura 2.4: continuación del error en rmd La función read.table() no completa de manera automática las celdas vacías con un valor por defecto como NA. Por este motivo, si alguna fila del archivo no contiene el número esperado de columnas (en este caso, 14), se genera un mensaje de error durante la importación. Para solucionar este inconveniente, puede añadirse el parámetro fill = TRUE, lo que permite a R rellenar los espacios vacíos con NA y mantener la estructura correcta del data.frame. Code df &lt;- read.table(&quot;data/StudyArea.csv&quot;, header = TRUE, fill = TRUE, sep = &quot;,&quot;) nrow(df) ## [1] 153095 Al ejecutar esta instrucción, el contenido del archivo se importa a un objeto de tipo data frame. Sin embargo, al revisar la pestaña Global Environment en RStudio, se observa que solo se han cargado 153095 registros, a pesar de que el archivo original contiene más de 400000. La causa de esta diferencia suele estar en el manejo de las comillas (simples o dobles) presentes dentro del archivo csv, las cuales pueden interrumpir la lectura y provocar que algunos registros sean descartados. Para corregir este problema, se debe añadir el parámetro quote = \"\", que le indica a R que ignore las comillas y procese correctamente todas las filas del archivo. Code df = read.table(&quot;data/StudyArea.csv&quot;, header=TRUE, fill=TRUE, quote=&quot;\\&quot;&quot;, sep=&quot;,&quot;) nrow(df) ## [1] 439362 Al ejecutar esta línea de código, se deberían importar 440476 registros. Los datos se cargan en un objeto de tipo R data.frame, que es una estructura similar a una tabla. Por ahora, puede pensarse en ellos como tablas que contienen columnas y filas. Observación La función read.table() se utiliza normalmente para cargar archivos de texto delimitados por tabulaciones. Sin embargo, muchas personas intentan emplearla directamente con archivos en formato csv sin especificar los parámetros adecuados, lo que puede generar errores en la importación. Una alternativa más práctica es usar la función read.csv(), como veremos en el siguiente paso. 2.2.2 Importación de archivos txt delimitados por tabulación con read.table() La función read.table() se utiliza con frecuencia para leer el contenido de archivos delimitados por tabulaciones u otros separadores. En este ejemplo, se trabajará con el archivo all_genes_pombase.txt, ubicado en la carpeta RDataSets. Antes de importarlo en R, se recomienda abrir el archivo en Excel o en cualquier editor de texto para observar su estructura, campos y delimitadores. Una vez identificado el formato del archivo, en la consola de R puedes ejecutar el siguiente código para realizar la importación: Code # Lectura de archivo delimitado por tabulaciones genes &lt;- read.table(&quot;data/all_genes_pombase.txt&quot;, header = TRUE, sep = &quot;\\t&quot;, quote=&quot;\\&quot;&quot;) # numero de filas nrow(genes) ## [1] 7019 Code # Visualizar las primeras filas head(genes) ## ensembl_id name chromosome ## 1 SPAC1002.01 SPAC1002.01 I ## 2 SPAC1002.02 pom34 I ## 3 SPAC1002.03c gls2 I ## 4 SPAC1002.04c taf11 I ## 5 SPAC1002.05c jmj2 I ## 6 SPAC1002.06c bqt2 I ## description feature_type ## 1 conserved fungal protein protein_coding ## 2 nucleoporin Pom34 protein_coding ## 3 glucosidase II alpha subunit Gls2 protein_coding ## 4 transcription factor TFIID complex subunit Taf11 (predicted) protein_coding ## 5 histone demethylase Jmj2 protein_coding ## 6 bouquet formation protein Bqt2 protein_coding ## strand start end ## 1 1 1798347 1799015 ## 2 1 1799061 1800053 ## 3 -1 1799915 1803141 ## 4 -1 1803624 1804491 ## 5 -1 1804548 1806797 ## 6 -1 1807270 1807781 Esto permitirá cargar 7019 registros en un objeto data.frame. Es importante tener en cuenta que, aunque la función realiza la importación, varios de sus parámetros deben configurarse adecuadamente al momento de leer el dataset, lo que hace que el proceso no sea tan directo ni automático como podría suponerse inicialmente. 2.2.3 Importación de archivos csv con read.csv() Definición: read.csv() La función read.csv() es una función incorporada en R que permite importar archivos delimitados por comas (csv) de manera sencilla. Está diseñada específicamente para este tipo de archivos y establece de forma predeterminada el argumento header = TRUE (la primera fila se toma como nombres de columna) y sep = “,” (coma como delimitador de campos). Esto hace que read.csv() sea una de las formas más rápidas y eficientes de cargar datos en R cuando provienen de archivos csv. La función read.csv() es una función incorporada en R que resulta casi idéntica a read.table(). La principal diferencia es que en read.csv() los argumentos de cabecera y relleno se establecen en TRUE por defecto, lo que facilita la carga de archivos delimitados por comas (csv). En este punto, se observa que usar read.csv() implifica notablemente el proceso de importación. A diferencia de read.table(), la función read.csv() gestiona automáticamente la mayoría de las configuraciones necesarias al leer un archivo csv. Esto permite cargar correctamente incluso archivos con más de 400000 registros sin tener que especificar tantos parámetros manualmente. Code # Lectura de archivo CSV con read.csv() df &lt;- read.csv(&quot;data/StudyArea.csv&quot;) # numero de fila nrow(df) ## [1] 439362 2.2.4 Uso de readr de tidyverse Definición: readr readr es el paquete del ecosistema tidyverse para lectura y escritura rápida de datos tabulares. Produce objetos tibble, maneja de forma estable codificaciones (UTF-8), tipos de columna y valores perdidos, e incluye herramientas para diagnosticar problemas de importación. Su API es consistente, minimalista y pensada para flujos reproducibles. Ventajas claves Velocidad y consistencia en lectura/escritura de archivos delimitados. Tipos de columnas explícitos con col_types y funciones col_*. Diagnóstico con spec() y problems(). Salida en tibble (imprime y maneja mejor columnas anchas/fechas). Soporte de locales (locale()) para decimales, fechas, codificación, etc. Funciones principales de lectura Función Propósito Formato/Delimitador read_csv() csv con punto como decimal , read_csv2() csv europeo (coma decimal) ; read_tsv() Valores separados por tabulador \\t read_delim(delim=) Delimitador personalizado Cualquiera (p. ej. \\|, :) read_table() Columnas separadas por espacios Espacios en blanco read_fwf() Formato de ancho fijo Anchos/posiciones read_lines() Leer líneas como vector de caracteres Texto read_file() Leer archivo completo como cadena única Texto read_rds() Leer archivo R serializado .rds Funciones de escritura Función Propósito write_csv() Escribir csv (punto decimal) write_csv2() Escribir csv (coma decimal) write_tsv() Escribir delimitado por tabulador write_delim() Escribir con delimitador personalizado write_rds() Guardar objeto R en .rds Argumentos comunes (lectura) Argumento Qué controla Ejemplo col_types Tipos de columnas (explícitos) col_types = cols(id = col_integer()) na Cadenas que se tratarán como NA na = c(\"\", \"NA\", \"NULL\") locale Configuración regional (decimal, fecha, tz, encoding) locale(decimal_mark = \",\") skip / n_max Filas a omitir / máximo de filas a leer skip = 2, n_max = 1e5 comment Prefijo de comentario para ignorar líneas comment = \"#\" guess_max Filas usadas para “adivinar” tipos guess_max = 100000 show_col_types Muestra la conjetura de tipos al leer show_col_types = FALSE Tip: cuando los tipos son críticos, no confíes solo en la inferencia: pasa col_types explícito. Veamos el siguiente ejemplo. Carguemos los siguientes datos: Code library(readr) # CSV con punto decimal y encabezados dfReadr &lt;- read_csv(&quot;data/StudyArea.csv&quot;, col_types = cols(.default = &quot;c&quot;), # Columnas (.default) como &quot;character&quot; col_names = TRUE) # la 1ra fila como nombres de las columnas head(dfReadr) ## # A tibble: 6 × 14 ## FID ORGANIZATI UNIT SUBUNIT SUBUNIT2 FIRENAME CAUSE YEAR_ STARTDATED ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 0 FWS 81682 USCADBR San Diego Bay … PUMP HO… Human 2001 1/1/01 0:… ## 2 1 FWS 81682 USCADBR San Diego Bay … I5 Human 2002 5/3/02 0:… ## 3 2 FWS 81682 USCADBR San Diego Bay … SOUTHBAY Human 2002 6/1/02 0:… ## 4 3 FWS 81682 USCADBR San Diego Bay … MARINA Human 2001 7/12/01 0… ## 5 4 FWS 81682 USCADBR San Diego Bay … HILL Human 1994 9/13/94 0… ## 6 5 FWS 81682 USCADBR San Diego Bay … IRRIGAT… Human 1994 4/22/94 0… ## # ℹ 5 more variables: CONTRDATED &lt;chr&gt;, OUTDATED &lt;chr&gt;, STATE &lt;chr&gt;, ## # STATE_FIPS &lt;chr&gt;, TOTALACRES &lt;chr&gt; Code spec(dfReadr) # Esquema de tipos ## cols( ## .default = col_character(), ## FID = col_character(), ## ORGANIZATI = col_character(), ## UNIT = col_character(), ## SUBUNIT = col_character(), ## SUBUNIT2 = col_character(), ## FIRENAME = col_character(), ## CAUSE = col_character(), ## YEAR_ = col_character(), ## STARTDATED = col_character(), ## CONTRDATED = col_character(), ## OUTDATED = col_character(), ## STATE = col_character(), ## STATE_FIPS = col_character(), ## TOTALACRES = col_character() ## ) Al ejecutar nuevamente la función sin el argumento col_types, R* intentará detectar automáticamente el tipo de dato de cada columna. En este proceso se mostrará primero un listado con los nombres de las columnas y el tipo asignado a cada una, seguido de un mensaje de advertencia que indica la presencia de errores de análisis durante la importación, lo cual ejemplifica las inconsistencias que pueden surgir al dejar la inferencia de tipos en manos del sistema. Actualice el código como se muestra a continuación y ejecútelo nuevamente. En este caso, se especifica que la columna UNIT debe ser importada como un dato de tipo carácter (texto): Code dfReadr = read_csv(&quot;data/StudyArea.csv&quot;, col_types = list(FID = col_character()), col_names = TRUE) head(dfReadr) ## # A tibble: 6 × 14 ## FID ORGANIZATI UNIT SUBUNIT SUBUNIT2 FIRENAME CAUSE YEAR_ STARTDATED ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 0 FWS 81682 USCADBR San Diego Bay … PUMP HO… Human 2001 1/1/01 0:… ## 2 1 FWS 81682 USCADBR San Diego Bay … I5 Human 2002 5/3/02 0:… ## 3 2 FWS 81682 USCADBR San Diego Bay … SOUTHBAY Human 2002 6/1/02 0:… ## 4 3 FWS 81682 USCADBR San Diego Bay … MARINA Human 2001 7/12/01 0… ## 5 4 FWS 81682 USCADBR San Diego Bay … HILL Human 1994 9/13/94 0… ## 6 5 FWS 81682 USCADBR San Diego Bay … IRRIGAT… Human 1994 4/22/94 0… ## # ℹ 5 more variables: CONTRDATED &lt;chr&gt;, OUTDATED &lt;chr&gt;, STATE &lt;chr&gt;, ## # STATE_FIPS &lt;dbl&gt;, TOTALACRES &lt;dbl&gt; 2.3 El paquete dplyr Definición El paquete dplyr fue desarrollado por Hadley Wickham de RStudio y es una versión optimizada y destilada de su paquete plyr. Una importante contribución de dplyr es que proporciona una gramática (en particular, verbos) para la manipulación de datos y operación con data frames. Con esta gramática se puede comunicar de forma comprensible lo que se está haciendo a un data frame, lo cual es muy útil porque proporciona una abstracción para la manipulación de datos que antes no existía. Otra ventaja es que las funciones de dplyr son muy rápidas, ya que muchas operaciones clave están codificadas en C++. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
